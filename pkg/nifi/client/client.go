// Package nifi implements the Azure ARM Nifi service API version 1.0.0.
//
// The Rest Api provides programmatic access to command and control a NiFi instance in real time. Start and
// stop processors, monitor queues, query provenance data, and more. Each endpoint below includes a description,
// definitions of the expected input and output, potential response codes, and the authorizations required
// to invoke each service.
package nifi

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "io"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Nifi
DefaultBaseURI = "/nifi-api")

// BaseClient is the base client for Nifi.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // ClearState sends the clear state request.
        // Parameters:
            // ID - the controller service id.
    func (client BaseClient) ClearState(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ClearState")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ClearStatePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState", nil , "Failure preparing request")
        return
        }

                resp, err := client.ClearStateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState", resp, "Failure sending request")
                return
                }

                result, err = client.ClearStateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState", resp, "Failure responding to request")
                }

        return
        }

        // ClearStatePreparer prepares the ClearState request.
        func (client BaseClient) ClearStatePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}/state/clear-requests",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ClearStateSender sends the ClearState request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ClearStateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ClearStateResponder handles the response to the ClearState request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ClearStateResponder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ClearState1 sends the clear state 1 request.
        // Parameters:
            // ID - the processor id.
    func (client BaseClient) ClearState1(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ClearState1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ClearState1Preparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState1", nil , "Failure preparing request")
        return
        }

                resp, err := client.ClearState1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState1", resp, "Failure sending request")
                return
                }

                result, err = client.ClearState1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState1", resp, "Failure responding to request")
                }

        return
        }

        // ClearState1Preparer prepares the ClearState1 request.
        func (client BaseClient) ClearState1Preparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}/state/clear-requests",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ClearState1Sender sends the ClearState1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ClearState1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ClearState1Responder handles the response to the ClearState1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ClearState1Responder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ClearState2 sends the clear state 2 request.
        // Parameters:
            // ID - the reporting task id.
    func (client BaseClient) ClearState2(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ClearState2")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ClearState2Preparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState2", nil , "Failure preparing request")
        return
        }

                resp, err := client.ClearState2Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState2", resp, "Failure sending request")
                return
                }

                result, err = client.ClearState2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ClearState2", resp, "Failure responding to request")
                }

        return
        }

        // ClearState2Preparer prepares the ClearState2 request.
        func (client BaseClient) ClearState2Preparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}/state/clear-requests",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ClearState2Sender sends the ClearState2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ClearState2Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ClearState2Responder handles the response to the ClearState2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ClearState2Responder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CommitInputPortTransaction sends the commit input port transaction request.
        // Parameters:
            // responseCode - the response code. Available values are BAD_CHECKSUM(19), CONFIRM_TRANSACTION(12) or
            // CANCEL_TRANSACTION(15).
            // portID - the input port id.
            // transactionID - the transaction id.
    func (client BaseClient) CommitInputPortTransaction(ctx context.Context, responseCode int32, portID string, transactionID string) (result TransactionResultEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CommitInputPortTransaction")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CommitInputPortTransactionPreparer(ctx, responseCode, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitInputPortTransaction", nil , "Failure preparing request")
        return
        }

                resp, err := client.CommitInputPortTransactionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitInputPortTransaction", resp, "Failure sending request")
                return
                }

                result, err = client.CommitInputPortTransactionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitInputPortTransaction", resp, "Failure responding to request")
                }

        return
        }

        // CommitInputPortTransactionPreparer prepares the CommitInputPortTransaction request.
        func (client BaseClient) CommitInputPortTransactionPreparer(ctx context.Context, responseCode int32, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

                        queryParameters := map[string]interface{} {
            "responseCode": autorest.Encode("query",responseCode),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/input-ports/{portId}/transactions/{transactionId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CommitInputPortTransactionSender sends the CommitInputPortTransaction request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CommitInputPortTransactionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CommitInputPortTransactionResponder handles the response to the CommitInputPortTransaction request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CommitInputPortTransactionResponder(resp *http.Response) (result TransactionResultEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CommitOutputPortTransaction sends the commit output port transaction request.
        // Parameters:
            // responseCode - the response code. Available values are CONFIRM_TRANSACTION(12) or CANCEL_TRANSACTION(15).
            // checksum - a checksum calculated at client side using CRC32 to check flow file content integrity. It must
            // match with the value calculated at server side.
            // portID - the output port id.
            // transactionID - the transaction id.
    func (client BaseClient) CommitOutputPortTransaction(ctx context.Context, responseCode int32, checksum string, portID string, transactionID string) (result TransactionResultEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CommitOutputPortTransaction")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CommitOutputPortTransactionPreparer(ctx, responseCode, checksum, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitOutputPortTransaction", nil , "Failure preparing request")
        return
        }

                resp, err := client.CommitOutputPortTransactionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitOutputPortTransaction", resp, "Failure sending request")
                return
                }

                result, err = client.CommitOutputPortTransactionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CommitOutputPortTransaction", resp, "Failure responding to request")
                }

        return
        }

        // CommitOutputPortTransactionPreparer prepares the CommitOutputPortTransaction request.
        func (client BaseClient) CommitOutputPortTransactionPreparer(ctx context.Context, responseCode int32, checksum string, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

                        queryParameters := map[string]interface{} {
            "checksum": autorest.Encode("query",checksum),
            "responseCode": autorest.Encode("query",responseCode),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/output-ports/{portId}/transactions/{transactionId}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CommitOutputPortTransactionSender sends the CommitOutputPortTransaction request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CommitOutputPortTransactionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CommitOutputPortTransactionResponder handles the response to the CommitOutputPortTransaction request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CommitOutputPortTransactionResponder(resp *http.Response) (result TransactionResultEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CopySnippet sends the copy snippet request.
        // Parameters:
            // ID - the process group id.
            // body - the copy snippet request.
    func (client BaseClient) CopySnippet(ctx context.Context, ID string, body CopySnippetRequestEntity) (result FlowSnippetEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CopySnippet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CopySnippetPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CopySnippet", nil , "Failure preparing request")
        return
        }

                resp, err := client.CopySnippetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CopySnippet", resp, "Failure sending request")
                return
                }

                result, err = client.CopySnippetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CopySnippet", resp, "Failure responding to request")
                }

        return
        }

        // CopySnippetPreparer prepares the CopySnippet request.
        func (client BaseClient) CopySnippetPreparer(ctx context.Context, ID string, body CopySnippetRequestEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/snippet-instance",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CopySnippetSender sends the CopySnippet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CopySnippetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CopySnippetResponder handles the response to the CopySnippet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CopySnippetResponder(resp *http.Response) (result FlowSnippetEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateAccessPolicy sends the create access policy request.
        // Parameters:
            // body - the access policy configuration details.
    func (client BaseClient) CreateAccessPolicy(ctx context.Context, body AccessPolicyEntity) (result AccessPolicyEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateAccessPolicy")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.UserGroups", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateAccessPolicy", err.Error())
                }

                    req, err := client.CreateAccessPolicyPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessPolicy", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateAccessPolicySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessPolicy", resp, "Failure sending request")
                return
                }

                result, err = client.CreateAccessPolicyResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessPolicy", resp, "Failure responding to request")
                }

        return
        }

        // CreateAccessPolicyPreparer prepares the CreateAccessPolicy request.
        func (client BaseClient) CreateAccessPolicyPreparer(ctx context.Context, body AccessPolicyEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/policies"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateAccessPolicySender sends the CreateAccessPolicy request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateAccessPolicySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateAccessPolicyResponder handles the response to the CreateAccessPolicy request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateAccessPolicyResponder(resp *http.Response) (result AccessPolicyEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateAccessToken the token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded and
    // comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained within
    // the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'.
    func (client BaseClient) CreateAccessToken(ctx context.Context, username string, password string) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateAccessToken")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateAccessTokenPreparer(ctx, username, password)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessToken", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateAccessTokenSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessToken", resp, "Failure sending request")
                return
                }

                result, err = client.CreateAccessTokenResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessToken", resp, "Failure responding to request")
                }

        return
        }

        // CreateAccessTokenPreparer prepares the CreateAccessToken request.
        func (client BaseClient) CreateAccessTokenPreparer(ctx context.Context, username string, password string) (*http.Request, error) {
                formDataParameters := map[string]interface{} {
                }
                    if len(username) > 0 {
                    formDataParameters["username"] = username
                    }
                    if len(password) > 0 {
                    formDataParameters["password"] = password
                    }

                preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access/token"),
        autorest.WithFormData(autorest.MapToValues(formDataParameters)))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateAccessTokenSender sends the CreateAccessToken request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateAccessTokenSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateAccessTokenResponder handles the response to the CreateAccessToken request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateAccessTokenResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusForbidden,http.StatusConflict,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateAccessTokenFromTicket the token returned is formatted as a JSON Web Token (JWT). The token is base64 encoded
    // and comprised of three parts. The header, the body, and the signature. The expiration of the token is a contained
    // within the body. The token can be used in the Authorization header in the format 'Authorization: Bearer <token>'.
    func (client BaseClient) CreateAccessTokenFromTicket(ctx context.Context) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateAccessTokenFromTicket")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateAccessTokenFromTicketPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessTokenFromTicket", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateAccessTokenFromTicketSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessTokenFromTicket", resp, "Failure sending request")
                return
                }

                result, err = client.CreateAccessTokenFromTicketResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateAccessTokenFromTicket", resp, "Failure responding to request")
                }

        return
        }

        // CreateAccessTokenFromTicketPreparer prepares the CreateAccessTokenFromTicket request.
        func (client BaseClient) CreateAccessTokenFromTicketPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access/kerberos"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateAccessTokenFromTicketSender sends the CreateAccessTokenFromTicket request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateAccessTokenFromTicketSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateAccessTokenFromTicketResponder handles the response to the CreateAccessTokenFromTicket request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateAccessTokenFromTicketResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusConflict,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateConnection sends the create connection request.
        // Parameters:
            // ID - the process group id.
            // body - the connection configuration details.
    func (client BaseClient) CreateConnection(ctx context.Context, ID string, body ConnectionEntity) (result ConnectionEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateConnection")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Source", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Source.ID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "body.Component.Source.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.Destination", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Destination.ID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "body.Component.Destination.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.SelectedRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.SelectedRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AvailableRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AvailableRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateConnection", err.Error())
                }

                    req, err := client.CreateConnectionPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateConnection", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateConnectionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateConnection", resp, "Failure sending request")
                return
                }

                result, err = client.CreateConnectionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateConnection", resp, "Failure responding to request")
                }

        return
        }

        // CreateConnectionPreparer prepares the CreateConnection request.
        func (client BaseClient) CreateConnectionPreparer(ctx context.Context, ID string, body ConnectionEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/connections",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateConnectionSender sends the CreateConnection request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateConnectionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateConnectionResponder handles the response to the CreateConnection request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateConnectionResponder(resp *http.Response) (result ConnectionEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateControllerService sends the create controller service request.
        // Parameters:
            // body - the controller service configuration details.
    func (client BaseClient) CreateControllerService(ctx context.Context, body ControllerServiceEntity) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateControllerService")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateControllerService", err.Error())
                }

                    req, err := client.CreateControllerServicePreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateControllerServiceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService", resp, "Failure sending request")
                return
                }

                result, err = client.CreateControllerServiceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService", resp, "Failure responding to request")
                }

        return
        }

        // CreateControllerServicePreparer prepares the CreateControllerService request.
        func (client BaseClient) CreateControllerServicePreparer(ctx context.Context, body ControllerServiceEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/controller-services"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateControllerServiceSender sends the CreateControllerService request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateControllerServiceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateControllerServiceResponder handles the response to the CreateControllerService request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateControllerServiceResponder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateControllerService1 sends the create controller service 1 request.
        // Parameters:
            // ID - the process group id.
            // body - the controller service configuration details.
    func (client BaseClient) CreateControllerService1(ctx context.Context, ID string, body ControllerServiceEntity) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateControllerService1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateControllerService1", err.Error())
                }

                    req, err := client.CreateControllerService1Preparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService1", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateControllerService1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService1", resp, "Failure sending request")
                return
                }

                result, err = client.CreateControllerService1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateControllerService1", resp, "Failure responding to request")
                }

        return
        }

        // CreateControllerService1Preparer prepares the CreateControllerService1 request.
        func (client BaseClient) CreateControllerService1Preparer(ctx context.Context, ID string, body ControllerServiceEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/controller-services",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateControllerService1Sender sends the CreateControllerService1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateControllerService1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateControllerService1Responder handles the response to the CreateControllerService1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateControllerService1Responder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateDownloadToken the token returned is a base64 encoded string. It is valid for a single request up to five
    // minutes from being issued. It is used as a query parameter name 'access_token'.
    func (client BaseClient) CreateDownloadToken(ctx context.Context) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateDownloadToken")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateDownloadTokenPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDownloadToken", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateDownloadTokenSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDownloadToken", resp, "Failure sending request")
                return
                }

                result, err = client.CreateDownloadTokenResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDownloadToken", resp, "Failure responding to request")
                }

        return
        }

        // CreateDownloadTokenPreparer prepares the CreateDownloadToken request.
        func (client BaseClient) CreateDownloadTokenPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access/download-token"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateDownloadTokenSender sends the CreateDownloadToken request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateDownloadTokenSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateDownloadTokenResponder handles the response to the CreateDownloadToken request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateDownloadTokenResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusConflict,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateDropRequest sends the create drop request request.
        // Parameters:
            // ID - the connection id.
    func (client BaseClient) CreateDropRequest(ctx context.Context, ID string) (result DropRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateDropRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateDropRequestPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDropRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateDropRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDropRequest", resp, "Failure sending request")
                return
                }

                result, err = client.CreateDropRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateDropRequest", resp, "Failure responding to request")
                }

        return
        }

        // CreateDropRequestPreparer prepares the CreateDropRequest request.
        func (client BaseClient) CreateDropRequestPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/drop-requests",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateDropRequestSender sends the CreateDropRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateDropRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateDropRequestResponder handles the response to the CreateDropRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateDropRequestResponder(resp *http.Response) (result DropRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateFlowFileListing sends the create flow file listing request.
        // Parameters:
            // ID - the connection id.
    func (client BaseClient) CreateFlowFileListing(ctx context.Context, ID string) (result ListingRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateFlowFileListing")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateFlowFileListingPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFlowFileListing", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateFlowFileListingSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFlowFileListing", resp, "Failure sending request")
                return
                }

                result, err = client.CreateFlowFileListingResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFlowFileListing", resp, "Failure responding to request")
                }

        return
        }

        // CreateFlowFileListingPreparer prepares the CreateFlowFileListing request.
        func (client BaseClient) CreateFlowFileListingPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/listing-requests",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateFlowFileListingSender sends the CreateFlowFileListing request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateFlowFileListingSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateFlowFileListingResponder handles the response to the CreateFlowFileListing request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateFlowFileListingResponder(resp *http.Response) (result ListingRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusAccepted,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateFunnel sends the create funnel request.
        // Parameters:
            // ID - the process group id.
            // body - the funnel configuration details.
    func (client BaseClient) CreateFunnel(ctx context.Context, ID string, body FunnelEntity) (result FunnelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateFunnel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateFunnelPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFunnel", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateFunnelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFunnel", resp, "Failure sending request")
                return
                }

                result, err = client.CreateFunnelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateFunnel", resp, "Failure responding to request")
                }

        return
        }

        // CreateFunnelPreparer prepares the CreateFunnel request.
        func (client BaseClient) CreateFunnelPreparer(ctx context.Context, ID string, body FunnelEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/funnels",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateFunnelSender sends the CreateFunnel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateFunnelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateFunnelResponder handles the response to the CreateFunnel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateFunnelResponder(resp *http.Response) (result FunnelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateInputPort sends the create input port request.
        // Parameters:
            // ID - the process group id.
            // body - the input port configuration details.
    func (client BaseClient) CreateInputPort(ctx context.Context, ID string, body PortEntity) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateInputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.GroupAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.GroupAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateInputPort", err.Error())
                }

                    req, err := client.CreateInputPortPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateInputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateInputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateInputPort", resp, "Failure sending request")
                return
                }

                result, err = client.CreateInputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateInputPort", resp, "Failure responding to request")
                }

        return
        }

        // CreateInputPortPreparer prepares the CreateInputPort request.
        func (client BaseClient) CreateInputPortPreparer(ctx context.Context, ID string, body PortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/input-ports",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateInputPortSender sends the CreateInputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateInputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateInputPortResponder handles the response to the CreateInputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateInputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateLabel sends the create label request.
        // Parameters:
            // ID - the process group id.
            // body - the label configuration details.
    func (client BaseClient) CreateLabel(ctx context.Context, ID string, body LabelEntity) (result LabelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateLabel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateLabelPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateLabel", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateLabelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateLabel", resp, "Failure sending request")
                return
                }

                result, err = client.CreateLabelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateLabel", resp, "Failure responding to request")
                }

        return
        }

        // CreateLabelPreparer prepares the CreateLabel request.
        func (client BaseClient) CreateLabelPreparer(ctx context.Context, ID string, body LabelEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/labels",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateLabelSender sends the CreateLabel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateLabelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateLabelResponder handles the response to the CreateLabel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateLabelResponder(resp *http.Response) (result LabelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateOutputPort sends the create output port request.
        // Parameters:
            // ID - the process group id.
            // body - the output port configuration.
    func (client BaseClient) CreateOutputPort(ctx context.Context, ID string, body PortEntity) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateOutputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.GroupAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.GroupAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateOutputPort", err.Error())
                }

                    req, err := client.CreateOutputPortPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateOutputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateOutputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateOutputPort", resp, "Failure sending request")
                return
                }

                result, err = client.CreateOutputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateOutputPort", resp, "Failure responding to request")
                }

        return
        }

        // CreateOutputPortPreparer prepares the CreateOutputPort request.
        func (client BaseClient) CreateOutputPortPreparer(ctx context.Context, ID string, body PortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/output-ports",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateOutputPortSender sends the CreateOutputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateOutputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateOutputPortResponder handles the response to the CreateOutputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateOutputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreatePortTransaction sends the create port transaction request.
        // Parameters:
            // portType - the port type.
    func (client BaseClient) CreatePortTransaction(ctx context.Context, portType string, portID string) (result TransactionResultEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreatePortTransaction")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreatePortTransactionPreparer(ctx, portType, portID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreatePortTransaction", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreatePortTransactionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreatePortTransaction", resp, "Failure sending request")
                return
                }

                result, err = client.CreatePortTransactionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreatePortTransaction", resp, "Failure responding to request")
                }

        return
        }

        // CreatePortTransactionPreparer prepares the CreatePortTransaction request.
        func (client BaseClient) CreatePortTransactionPreparer(ctx context.Context, portType string, portID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "portType": autorest.Encode("path",portType),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/{portType}/{portId}/transactions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreatePortTransactionSender sends the CreatePortTransaction request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreatePortTransactionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreatePortTransactionResponder handles the response to the CreatePortTransaction request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreatePortTransactionResponder(resp *http.Response) (result TransactionResultEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateProcessGroup sends the create process group request.
        // Parameters:
            // ID - the process group id.
            // body - the process group configuration details.
    func (client BaseClient) CreateProcessGroup(ctx context.Context, ID string, body ProcessGroupEntity) (result ProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateProcessGroupPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.CreateProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // CreateProcessGroupPreparer prepares the CreateProcessGroup request.
        func (client BaseClient) CreateProcessGroupPreparer(ctx context.Context, ID string, body ProcessGroupEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/process-groups",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateProcessGroupSender sends the CreateProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateProcessGroupResponder handles the response to the CreateProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateProcessGroupResponder(resp *http.Response) (result ProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateProcessor sends the create processor request.
        // Parameters:
            // ID - the process group id.
            // body - the processor configuration details.
    func (client BaseClient) CreateProcessor(ctx context.Context, ID string, body ProcessorEntity) (result ProcessorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateProcessor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config.AutoTerminatedRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config.AutoTerminatedRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateProcessor", err.Error())
                }

                    req, err := client.CreateProcessorPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessor", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateProcessorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessor", resp, "Failure sending request")
                return
                }

                result, err = client.CreateProcessorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateProcessor", resp, "Failure responding to request")
                }

        return
        }

        // CreateProcessorPreparer prepares the CreateProcessor request.
        func (client BaseClient) CreateProcessorPreparer(ctx context.Context, ID string, body ProcessorEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/processors",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateProcessorSender sends the CreateProcessor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateProcessorSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateProcessorResponder handles the response to the CreateProcessor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateProcessorResponder(resp *http.Response) (result ProcessorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateRemoteProcessGroup sends the create remote process group request.
        // Parameters:
            // ID - the process group id.
            // body - the remote process group configuration details.
    func (client BaseClient) CreateRemoteProcessGroup(ctx context.Context, ID string, body RemoteProcessGroupEntity) (result RemoteProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateRemoteProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.InputPorts", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.InputPorts", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.Contents.OutputPorts", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.OutputPorts", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateRemoteProcessGroup", err.Error())
                }

                    req, err := client.CreateRemoteProcessGroupPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateRemoteProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateRemoteProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateRemoteProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.CreateRemoteProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateRemoteProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // CreateRemoteProcessGroupPreparer prepares the CreateRemoteProcessGroup request.
        func (client BaseClient) CreateRemoteProcessGroupPreparer(ctx context.Context, ID string, body RemoteProcessGroupEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/remote-process-groups",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateRemoteProcessGroupSender sends the CreateRemoteProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateRemoteProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateRemoteProcessGroupResponder handles the response to the CreateRemoteProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateRemoteProcessGroupResponder(resp *http.Response) (result RemoteProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateReportingTask sends the create reporting task request.
        // Parameters:
            // body - the reporting task configuration details.
    func (client BaseClient) CreateReportingTask(ctx context.Context, body ReportingTaskEntity) (result ReportingTaskEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateReportingTask")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateReportingTaskPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateReportingTask", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateReportingTaskSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateReportingTask", resp, "Failure sending request")
                return
                }

                result, err = client.CreateReportingTaskResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateReportingTask", resp, "Failure responding to request")
                }

        return
        }

        // CreateReportingTaskPreparer prepares the CreateReportingTask request.
        func (client BaseClient) CreateReportingTaskPreparer(ctx context.Context, body ReportingTaskEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/reporting-tasks"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateReportingTaskSender sends the CreateReportingTask request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateReportingTaskSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateReportingTaskResponder handles the response to the CreateReportingTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateReportingTaskResponder(resp *http.Response) (result ReportingTaskEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateSnippet sends the create snippet request.
        // Parameters:
            // body - the snippet configuration details.
    func (client BaseClient) CreateSnippet(ctx context.Context, body SnippetEntity) (result SnippetEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateSnippet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateSnippetPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateSnippet", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateSnippetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateSnippet", resp, "Failure sending request")
                return
                }

                result, err = client.CreateSnippetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateSnippet", resp, "Failure responding to request")
                }

        return
        }

        // CreateSnippetPreparer prepares the CreateSnippet request.
        func (client BaseClient) CreateSnippetPreparer(ctx context.Context, body SnippetEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/snippets"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateSnippetSender sends the CreateSnippet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateSnippetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateSnippetResponder handles the response to the CreateSnippet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateSnippetResponder(resp *http.Response) (result SnippetEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateTemplate sends the create template request.
        // Parameters:
            // ID - the process group id.
            // body - the create template request.
    func (client BaseClient) CreateTemplate(ctx context.Context, ID string, body CreateTemplateRequestEntity) (result TemplateEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateTemplatePreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.CreateTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateTemplate", resp, "Failure responding to request")
                }

        return
        }

        // CreateTemplatePreparer prepares the CreateTemplate request.
        func (client BaseClient) CreateTemplatePreparer(ctx context.Context, ID string, body CreateTemplateRequestEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/templates",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateTemplateSender sends the CreateTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateTemplateResponder handles the response to the CreateTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateTemplateResponder(resp *http.Response) (result TemplateEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateUIExtensionToken the token returned is a base64 encoded string. It is valid for a single request up to five
    // minutes from being issued. It is used as a query parameter name 'access_token'.
    func (client BaseClient) CreateUIExtensionToken(ctx context.Context) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateUIExtensionToken")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.CreateUIExtensionTokenPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUIExtensionToken", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateUIExtensionTokenSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUIExtensionToken", resp, "Failure sending request")
                return
                }

                result, err = client.CreateUIExtensionTokenResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUIExtensionToken", resp, "Failure responding to request")
                }

        return
        }

        // CreateUIExtensionTokenPreparer prepares the CreateUIExtensionToken request.
        func (client BaseClient) CreateUIExtensionTokenPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access/ui-extension-token"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateUIExtensionTokenSender sends the CreateUIExtensionToken request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateUIExtensionTokenSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateUIExtensionTokenResponder handles the response to the CreateUIExtensionToken request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateUIExtensionTokenResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusForbidden,http.StatusConflict,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateUser note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // body - the user configuration details.
    func (client BaseClient) CreateUser(ctx context.Context, body UserEntity) (result UserEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateUser")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AccessPolicies", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AccessPolicies", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateUser", err.Error())
                }

                    req, err := client.CreateUserPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUser", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateUserSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUser", resp, "Failure sending request")
                return
                }

                result, err = client.CreateUserResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUser", resp, "Failure responding to request")
                }

        return
        }

        // CreateUserPreparer prepares the CreateUser request.
        func (client BaseClient) CreateUserPreparer(ctx context.Context, body UserEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/tenants/users"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateUserSender sends the CreateUser request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateUserSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateUserResponder handles the response to the CreateUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateUserResponder(resp *http.Response) (result UserEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // CreateUserGroup note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // body - the user group configuration details.
    func (client BaseClient) CreateUserGroup(ctx context.Context, body UserGroupEntity) (result UserGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.CreateUserGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AccessPolicies", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AccessPolicies", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "CreateUserGroup", err.Error())
                }

                    req, err := client.CreateUserGroupPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUserGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.CreateUserGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUserGroup", resp, "Failure sending request")
                return
                }

                result, err = client.CreateUserGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "CreateUserGroup", resp, "Failure responding to request")
                }

        return
        }

        // CreateUserGroupPreparer prepares the CreateUserGroup request.
        func (client BaseClient) CreateUserGroupPreparer(ctx context.Context, body UserGroupEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/tenants/user-groups"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // CreateUserGroupSender sends the CreateUserGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) CreateUserGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // CreateUserGroupResponder handles the response to the CreateUserGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) CreateUserGroupResponder(resp *http.Response) (result UserGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteConnection sends the delete connection request.
        // Parameters:
            // ID - the connection id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) DeleteConnection(ctx context.Context, ID string, version string, clientID string) (result ConnectionEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteConnection")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteConnectionPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteConnection", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteConnectionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteConnection", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteConnectionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteConnection", resp, "Failure responding to request")
                }

        return
        }

        // DeleteConnectionPreparer prepares the DeleteConnection request.
        func (client BaseClient) DeleteConnectionPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/connections/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteConnectionSender sends the DeleteConnection request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteConnectionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteConnectionResponder handles the response to the DeleteConnection request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteConnectionResponder(resp *http.Response) (result ConnectionEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteHistory sends the delete history request.
        // Parameters:
            // endDate - purge actions before this date/time.
    func (client BaseClient) DeleteHistory(ctx context.Context, endDate string) (result HistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteHistoryPreparer(ctx, endDate)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteHistory", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteHistory", resp, "Failure responding to request")
                }

        return
        }

        // DeleteHistoryPreparer prepares the DeleteHistory request.
        func (client BaseClient) DeleteHistoryPreparer(ctx context.Context, endDate string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "endDate": autorest.Encode("query",endDate),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/history"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteHistorySender sends the DeleteHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteHistoryResponder handles the response to the DeleteHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteHistoryResponder(resp *http.Response) (result HistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteLineage sends the delete lineage request.
        // Parameters:
            // ID - the id of the lineage query.
            // clusterNodeID - the id of the node where this query exists if clustered.
    func (client BaseClient) DeleteLineage(ctx context.Context, ID string, clusterNodeID string) (result LineageEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteLineage")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteLineagePreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteLineage", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteLineageSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteLineage", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteLineageResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteLineage", resp, "Failure responding to request")
                }

        return
        }

        // DeleteLineagePreparer prepares the DeleteLineage request.
        func (client BaseClient) DeleteLineagePreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance/lineage/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteLineageSender sends the DeleteLineage request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteLineageSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteLineageResponder handles the response to the DeleteLineage request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteLineageResponder(resp *http.Response) (result LineageEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteListingRequest sends the delete listing request request.
        // Parameters:
            // ID - the connection id.
            // listingRequestID - the listing request id.
    func (client BaseClient) DeleteListingRequest(ctx context.Context, ID string, listingRequestID string) (result DropRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteListingRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteListingRequestPreparer(ctx, ID, listingRequestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteListingRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteListingRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteListingRequest", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteListingRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteListingRequest", resp, "Failure responding to request")
                }

        return
        }

        // DeleteListingRequestPreparer prepares the DeleteListingRequest request.
        func (client BaseClient) DeleteListingRequestPreparer(ctx context.Context, ID string, listingRequestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                "listing-request-id": autorest.Encode("path",listingRequestID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/listing-requests/{listing-request-id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteListingRequestSender sends the DeleteListingRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteListingRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteListingRequestResponder handles the response to the DeleteListingRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteListingRequestResponder(resp *http.Response) (result DropRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteNode sends the delete node request.
        // Parameters:
            // ID - the node id.
    func (client BaseClient) DeleteNode(ctx context.Context, ID string) (result NodeEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteNode")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteNodePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteNode", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteNodeSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteNode", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteNodeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteNode", resp, "Failure responding to request")
                }

        return
        }

        // DeleteNodePreparer prepares the DeleteNode request.
        func (client BaseClient) DeleteNodePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller/cluster/nodes/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteNodeSender sends the DeleteNode request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteNodeSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteNodeResponder handles the response to the DeleteNode request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteNodeResponder(resp *http.Response) (result NodeEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteProcessor sends the delete processor request.
        // Parameters:
            // ID - the processor id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) DeleteProcessor(ctx context.Context, ID string, version string, clientID string) (result ProcessorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteProcessor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteProcessorPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProcessor", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteProcessorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProcessor", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteProcessorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProcessor", resp, "Failure responding to request")
                }

        return
        }

        // DeleteProcessorPreparer prepares the DeleteProcessor request.
        func (client BaseClient) DeleteProcessorPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteProcessorSender sends the DeleteProcessor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteProcessorSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteProcessorResponder handles the response to the DeleteProcessor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteProcessorResponder(resp *http.Response) (result ProcessorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteProvenance sends the delete provenance request.
        // Parameters:
            // ID - the id of the provenance query.
            // clusterNodeID - the id of the node where this query exists if clustered.
    func (client BaseClient) DeleteProvenance(ctx context.Context, ID string, clusterNodeID string) (result ProvenanceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteProvenance")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteProvenancePreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProvenance", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteProvenanceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProvenance", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteProvenanceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteProvenance", resp, "Failure responding to request")
                }

        return
        }

        // DeleteProvenancePreparer prepares the DeleteProvenance request.
        func (client BaseClient) DeleteProvenancePreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteProvenanceSender sends the DeleteProvenance request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteProvenanceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteProvenanceResponder handles the response to the DeleteProvenance request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteProvenanceResponder(resp *http.Response) (result ProvenanceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DeleteSnippet sends the delete snippet request.
        // Parameters:
            // ID - the snippet id.
    func (client BaseClient) DeleteSnippet(ctx context.Context, ID string) (result SnippetEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DeleteSnippet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DeleteSnippetPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteSnippet", nil , "Failure preparing request")
        return
        }

                resp, err := client.DeleteSnippetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteSnippet", resp, "Failure sending request")
                return
                }

                result, err = client.DeleteSnippetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DeleteSnippet", resp, "Failure responding to request")
                }

        return
        }

        // DeleteSnippetPreparer prepares the DeleteSnippet request.
        func (client BaseClient) DeleteSnippetPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/snippets/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DeleteSnippetSender sends the DeleteSnippet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DeleteSnippetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DeleteSnippetResponder handles the response to the DeleteSnippet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DeleteSnippetResponder(resp *http.Response) (result SnippetEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // DownloadFlowFileContent sends the download flow file content request.
        // Parameters:
            // ID - the connection id.
            // flowfileUUID - the flowfile uuid.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
            // clusterNodeID - the id of the node where the content exists if clustered.
    func (client BaseClient) DownloadFlowFileContent(ctx context.Context, ID string, flowfileUUID string, clientID string, clusterNodeID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.DownloadFlowFileContent")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.DownloadFlowFileContentPreparer(ctx, ID, flowfileUUID, clientID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DownloadFlowFileContent", nil , "Failure preparing request")
        return
        }

                resp, err := client.DownloadFlowFileContentSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DownloadFlowFileContent", resp, "Failure sending request")
                return
                }

                result, err = client.DownloadFlowFileContentResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "DownloadFlowFileContent", resp, "Failure responding to request")
                }

        return
        }

        // DownloadFlowFileContentPreparer prepares the DownloadFlowFileContent request.
        func (client BaseClient) DownloadFlowFileContentPreparer(ctx context.Context, ID string, flowfileUUID string, clientID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "flowfile-uuid": autorest.Encode("path",flowfileUUID),
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/flowfiles/{flowfile-uuid}/content",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // DownloadFlowFileContentSender sends the DownloadFlowFileContent request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) DownloadFlowFileContentSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // DownloadFlowFileContentResponder handles the response to the DownloadFlowFileContent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) DownloadFlowFileContentResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ExportTemplate sends the export template request.
        // Parameters:
            // ID - the template id.
    func (client BaseClient) ExportTemplate(ctx context.Context, ID string) (result TemplateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExportTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExportTemplatePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExportTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExportTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExportTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.ExportTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExportTemplate", resp, "Failure responding to request")
                }

        return
        }

        // ExportTemplatePreparer prepares the ExportTemplate request.
        func (client BaseClient) ExportTemplatePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/templates/{id}/download",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExportTemplateSender sends the ExportTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExportTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExportTemplateResponder handles the response to the ExportTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExportTemplateResponder(resp *http.Response) (result TemplateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ExtendInputPortTransactionTTL sends the extend input port transaction ttl request.
    func (client BaseClient) ExtendInputPortTransactionTTL(ctx context.Context, portID string, transactionID string) (result TransactionResultEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExtendInputPortTransactionTTL")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExtendInputPortTransactionTTLPreparer(ctx, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendInputPortTransactionTTL", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExtendInputPortTransactionTTLSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendInputPortTransactionTTL", resp, "Failure sending request")
                return
                }

                result, err = client.ExtendInputPortTransactionTTLResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendInputPortTransactionTTL", resp, "Failure responding to request")
                }

        return
        }

        // ExtendInputPortTransactionTTLPreparer prepares the ExtendInputPortTransactionTTL request.
        func (client BaseClient) ExtendInputPortTransactionTTLPreparer(ctx context.Context, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/input-ports/{portId}/transactions/{transactionId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExtendInputPortTransactionTTLSender sends the ExtendInputPortTransactionTTL request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExtendInputPortTransactionTTLSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExtendInputPortTransactionTTLResponder handles the response to the ExtendInputPortTransactionTTL request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExtendInputPortTransactionTTLResponder(resp *http.Response) (result TransactionResultEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ExtendOutputPortTransactionTTL sends the extend output port transaction ttl request.
    func (client BaseClient) ExtendOutputPortTransactionTTL(ctx context.Context, portID string, transactionID string) (result TransactionResultEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExtendOutputPortTransactionTTL")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExtendOutputPortTransactionTTLPreparer(ctx, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendOutputPortTransactionTTL", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExtendOutputPortTransactionTTLSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendOutputPortTransactionTTL", resp, "Failure sending request")
                return
                }

                result, err = client.ExtendOutputPortTransactionTTLResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ExtendOutputPortTransactionTTL", resp, "Failure responding to request")
                }

        return
        }

        // ExtendOutputPortTransactionTTLPreparer prepares the ExtendOutputPortTransactionTTL request.
        func (client BaseClient) ExtendOutputPortTransactionTTLPreparer(ctx context.Context, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/output-ports/{portId}/transactions/{transactionId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExtendOutputPortTransactionTTLSender sends the ExtendOutputPortTransactionTTL request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExtendOutputPortTransactionTTLSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExtendOutputPortTransactionTTLResponder handles the response to the ExtendOutputPortTransactionTTL request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExtendOutputPortTransactionTTLResponder(resp *http.Response) (result TransactionResultEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GenerateClientID sends the generate client id request.
    func (client BaseClient) GenerateClientID(ctx context.Context) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GenerateClientID")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GenerateClientIDPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GenerateClientID", nil , "Failure preparing request")
        return
        }

                resp, err := client.GenerateClientIDSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GenerateClientID", resp, "Failure sending request")
                return
                }

                result, err = client.GenerateClientIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GenerateClientID", resp, "Failure responding to request")
                }

        return
        }

        // GenerateClientIDPreparer prepares the GenerateClientID request.
        func (client BaseClient) GenerateClientIDPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/client-id"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GenerateClientIDSender sends the GenerateClientID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GenerateClientIDSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GenerateClientIDResponder handles the response to the GenerateClientID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GenerateClientIDResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAboutInfo sends the get about info request.
    func (client BaseClient) GetAboutInfo(ctx context.Context) (result AboutEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAboutInfo")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAboutInfoPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAboutInfo", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAboutInfoSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAboutInfo", resp, "Failure sending request")
                return
                }

                result, err = client.GetAboutInfoResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAboutInfo", resp, "Failure responding to request")
                }

        return
        }

        // GetAboutInfoPreparer prepares the GetAboutInfo request.
        func (client BaseClient) GetAboutInfoPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/about"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAboutInfoSender sends the GetAboutInfo request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAboutInfoSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAboutInfoResponder handles the response to the GetAboutInfo request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAboutInfoResponder(resp *http.Response) (result AboutEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAccessPolicy sends the get access policy request.
        // Parameters:
            // ID - the access policy id.
    func (client BaseClient) GetAccessPolicy(ctx context.Context, ID string) (result AccessPolicyEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAccessPolicy")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAccessPolicyPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicy", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAccessPolicySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicy", resp, "Failure sending request")
                return
                }

                result, err = client.GetAccessPolicyResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicy", resp, "Failure responding to request")
                }

        return
        }

        // GetAccessPolicyPreparer prepares the GetAccessPolicy request.
        func (client BaseClient) GetAccessPolicyPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/policies/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAccessPolicySender sends the GetAccessPolicy request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAccessPolicySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAccessPolicyResponder handles the response to the GetAccessPolicy request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAccessPolicyResponder(resp *http.Response) (result AccessPolicyEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAccessPolicyForResource will return the effective policy if no component specific policy exists for the specified
    // action and resource. Must have Read permissions to the policy with the desired action and resource. Permissions for
    // the policy that is returned will be indicated in the response. This means the client could be authorized to get the
    // policy for a given component but the effective policy may be inherited from an ancestor Process Group. If the client
    // does not have permissions to that policy, the response will not include the policy and the permissions in the
    // response will be marked accordingly. If the client does not have permissions to the policy of the desired action and
    // resource a 403 response will be returned.
        // Parameters:
            // action - the request action.
            // resource - the resource of the policy.
    func (client BaseClient) GetAccessPolicyForResource(ctx context.Context, action string, resource string) (result AccessPolicyEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAccessPolicyForResource")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: resource,
                 Constraints: []validation.Constraint{	{Target: "resource", Name: validation.Pattern, Rule: ` .+`, Chain: nil }}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "GetAccessPolicyForResource", err.Error())
                }

                    req, err := client.GetAccessPolicyForResourcePreparer(ctx, action, resource)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicyForResource", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAccessPolicyForResourceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicyForResource", resp, "Failure sending request")
                return
                }

                result, err = client.GetAccessPolicyForResourceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessPolicyForResource", resp, "Failure responding to request")
                }

        return
        }

        // GetAccessPolicyForResourcePreparer prepares the GetAccessPolicyForResource request.
        func (client BaseClient) GetAccessPolicyForResourcePreparer(ctx context.Context, action string, resource string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "action": autorest.Encode("path",action),
                "resource": autorest.Encode("path",resource),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/policies/{action}/{resource}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAccessPolicyForResourceSender sends the GetAccessPolicyForResource request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAccessPolicyForResourceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAccessPolicyForResourceResponder handles the response to the GetAccessPolicyForResource request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAccessPolicyForResourceResponder(resp *http.Response) (result AccessPolicyEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAccessStatus note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetAccessStatus(ctx context.Context) (result AccessStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAccessStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetAccessStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetAccessStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetAccessStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAccessStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetAccessStatusPreparer prepares the GetAccessStatus request.
        func (client BaseClient) GetAccessStatusPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetAccessStatusSender sends the GetAccessStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetAccessStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetAccessStatusResponder handles the response to the GetAccessStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetAccessStatusResponder(resp *http.Response) (result AccessStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict,http.StatusInternalServerError),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetAction note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the action id.
    func (client BaseClient) GetAction(ctx context.Context, ID string) (result ActionEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetAction")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetActionPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAction", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetActionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAction", resp, "Failure sending request")
                return
                }

                result, err = client.GetActionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetAction", resp, "Failure responding to request")
                }

        return
        }

        // GetActionPreparer prepares the GetAction request.
        func (client BaseClient) GetActionPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/history/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetActionSender sends the GetAction request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetActionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetActionResponder handles the response to the GetAction request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetActionResponder(resp *http.Response) (result ActionEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetBanners sends the get banners request.
    func (client BaseClient) GetBanners(ctx context.Context) (result BannerEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetBanners")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetBannersPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBanners", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetBannersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBanners", resp, "Failure sending request")
                return
                }

                result, err = client.GetBannersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBanners", resp, "Failure responding to request")
                }

        return
        }

        // GetBannersPreparer prepares the GetBanners request.
        func (client BaseClient) GetBannersPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/banners"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetBannersSender sends the GetBanners request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetBannersSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetBannersResponder handles the response to the GetBanners request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetBannersResponder(resp *http.Response) (result BannerEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetBulletinBoard sends the get bulletin board request.
        // Parameters:
            // after - includes bulletins with an id after this value.
            // sourceName - includes bulletins originating from this sources whose name match this regular expression.
            // message - includes bulletins whose message that match this regular expression.
            // sourceID - includes bulletins originating from this sources whose id match this regular expression.
            // groupID - includes bulletins originating from this sources whose group id match this regular expression.
            // limit - the number of bulletins to limit the response to.
    func (client BaseClient) GetBulletinBoard(ctx context.Context, after string, sourceName string, message string, sourceID string, groupID string, limit string) (result BulletinBoardEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetBulletinBoard")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetBulletinBoardPreparer(ctx, after, sourceName, message, sourceID, groupID, limit)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletinBoard", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetBulletinBoardSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletinBoard", resp, "Failure sending request")
                return
                }

                result, err = client.GetBulletinBoardResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletinBoard", resp, "Failure responding to request")
                }

        return
        }

        // GetBulletinBoardPreparer prepares the GetBulletinBoard request.
        func (client BaseClient) GetBulletinBoardPreparer(ctx context.Context, after string, sourceName string, message string, sourceID string, groupID string, limit string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(after) > 0 {
                queryParameters["after"] = autorest.Encode("query",after)
                }
                if len(sourceName) > 0 {
                queryParameters["sourceName"] = autorest.Encode("query",sourceName)
                }
                if len(message) > 0 {
                queryParameters["message"] = autorest.Encode("query",message)
                }
                if len(sourceID) > 0 {
                queryParameters["sourceId"] = autorest.Encode("query",sourceID)
                }
                if len(groupID) > 0 {
                queryParameters["groupId"] = autorest.Encode("query",groupID)
                }
                if len(limit) > 0 {
                queryParameters["limit"] = autorest.Encode("query",limit)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/bulletin-board"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetBulletinBoardSender sends the GetBulletinBoard request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetBulletinBoardSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetBulletinBoardResponder handles the response to the GetBulletinBoard request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetBulletinBoardResponder(resp *http.Response) (result BulletinBoardEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetBulletins sends the get bulletins request.
    func (client BaseClient) GetBulletins(ctx context.Context) (result ControllerBulletinsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetBulletins")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetBulletinsPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletins", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetBulletinsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletins", resp, "Failure sending request")
                return
                }

                result, err = client.GetBulletinsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetBulletins", resp, "Failure responding to request")
                }

        return
        }

        // GetBulletinsPreparer prepares the GetBulletins request.
        func (client BaseClient) GetBulletinsPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/controller/bulletins"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetBulletinsSender sends the GetBulletins request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetBulletinsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetBulletinsResponder handles the response to the GetBulletins request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetBulletinsResponder(resp *http.Response) (result ControllerBulletinsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetCluster returns the contents of the cluster including all nodes and their status.
    func (client BaseClient) GetCluster(ctx context.Context) (result ClusterEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetCluster")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetClusterPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCluster", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetClusterSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCluster", resp, "Failure sending request")
                return
                }

                result, err = client.GetClusterResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCluster", resp, "Failure responding to request")
                }

        return
        }

        // GetClusterPreparer prepares the GetCluster request.
        func (client BaseClient) GetClusterPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/cluster"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetClusterSender sends the GetCluster request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetClusterSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetClusterResponder handles the response to the GetCluster request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetClusterResponder(resp *http.Response) (result ClusterEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetClusterSummary sends the get cluster summary request.
    func (client BaseClient) GetClusterSummary(ctx context.Context) (result ControllerStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetClusterSummary")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetClusterSummaryPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetClusterSummary", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetClusterSummarySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetClusterSummary", resp, "Failure sending request")
                return
                }

                result, err = client.GetClusterSummaryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetClusterSummary", resp, "Failure responding to request")
                }

        return
        }

        // GetClusterSummaryPreparer prepares the GetClusterSummary request.
        func (client BaseClient) GetClusterSummaryPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/cluster/summary"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetClusterSummarySender sends the GetClusterSummary request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetClusterSummarySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetClusterSummaryResponder handles the response to the GetClusterSummary request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetClusterSummaryResponder(resp *http.Response) (result ControllerStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetComponentHistory note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // componentID - the component id.
    func (client BaseClient) GetComponentHistory(ctx context.Context, componentID string) (result ComponentHistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetComponentHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetComponentHistoryPreparer(ctx, componentID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetComponentHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetComponentHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetComponentHistory", resp, "Failure sending request")
                return
                }

                result, err = client.GetComponentHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetComponentHistory", resp, "Failure responding to request")
                }

        return
        }

        // GetComponentHistoryPreparer prepares the GetComponentHistory request.
        func (client BaseClient) GetComponentHistoryPreparer(ctx context.Context, componentID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "componentId": autorest.Encode("path",componentID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/history/components/{componentId}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetComponentHistorySender sends the GetComponentHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetComponentHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetComponentHistoryResponder handles the response to the GetComponentHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetComponentHistoryResponder(resp *http.Response) (result ComponentHistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetConnection sends the get connection request.
        // Parameters:
            // ID - the connection id.
    func (client BaseClient) GetConnection(ctx context.Context, ID string) (result ConnectionEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnection")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConnectionPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnection", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConnectionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnection", resp, "Failure sending request")
                return
                }

                result, err = client.GetConnectionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnection", resp, "Failure responding to request")
                }

        return
        }

        // GetConnectionPreparer prepares the GetConnection request.
        func (client BaseClient) GetConnectionPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/connections/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionSender sends the GetConnection request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConnectionResponder handles the response to the GetConnection request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConnectionResponder(resp *http.Response) (result ConnectionEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetConnections sends the get connections request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetConnections(ctx context.Context, ID string) (result ConnectionsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnections")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConnectionsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnections", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConnectionsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnections", resp, "Failure sending request")
                return
                }

                result, err = client.GetConnectionsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnections", resp, "Failure responding to request")
                }

        return
        }

        // GetConnectionsPreparer prepares the GetConnections request.
        func (client BaseClient) GetConnectionsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/connections",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionsSender sends the GetConnections request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConnectionsResponder handles the response to the GetConnections request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConnectionsResponder(resp *http.Response) (result ConnectionsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetConnectionStatus sends the get connection status request.
        // Parameters:
            // ID - the connection id.
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetConnectionStatus(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (result ConnectionStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnectionStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConnectionStatusPreparer(ctx, ID, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConnectionStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetConnectionStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetConnectionStatusPreparer prepares the GetConnectionStatus request.
        func (client BaseClient) GetConnectionStatusPreparer(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/connections/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionStatusSender sends the GetConnectionStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConnectionStatusResponder handles the response to the GetConnectionStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConnectionStatusResponder(resp *http.Response) (result ConnectionStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetConnectionStatusHistory sends the get connection status history request.
        // Parameters:
            // ID - the connection id.
    func (client BaseClient) GetConnectionStatusHistory(ctx context.Context, ID string) (result StatusHistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetConnectionStatusHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetConnectionStatusHistoryPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatusHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetConnectionStatusHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatusHistory", resp, "Failure sending request")
                return
                }

                result, err = client.GetConnectionStatusHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetConnectionStatusHistory", resp, "Failure responding to request")
                }

        return
        }

        // GetConnectionStatusHistoryPreparer prepares the GetConnectionStatusHistory request.
        func (client BaseClient) GetConnectionStatusHistoryPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/connections/{id}/status/history",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetConnectionStatusHistorySender sends the GetConnectionStatusHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetConnectionStatusHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetConnectionStatusHistoryResponder handles the response to the GetConnectionStatusHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetConnectionStatusHistoryResponder(resp *http.Response) (result StatusHistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerConfig sends the get controller config request.
    func (client BaseClient) GetControllerConfig(ctx context.Context) (result ControllerConfigurationEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerConfig")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerConfigPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerConfig", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerConfigSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerConfig", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerConfigResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerConfig", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerConfigPreparer prepares the GetControllerConfig request.
        func (client BaseClient) GetControllerConfigPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/config"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerConfigSender sends the GetControllerConfig request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerConfigSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerConfigResponder handles the response to the GetControllerConfig request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerConfigResponder(resp *http.Response) (result ControllerConfigurationEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerService sends the get controller service request.
        // Parameters:
            // ID - the controller service id.
    func (client BaseClient) GetControllerService(ctx context.Context, ID string) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerService")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerServicePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerService", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerServiceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerService", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerServiceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerService", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerServicePreparer prepares the GetControllerService request.
        func (client BaseClient) GetControllerServicePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerServiceSender sends the GetControllerService request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerServiceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerServiceResponder handles the response to the GetControllerService request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerServiceResponder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerServiceReferences sends the get controller service references request.
        // Parameters:
            // ID - the controller service id.
    func (client BaseClient) GetControllerServiceReferences(ctx context.Context, ID string) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerServiceReferences")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerServiceReferencesPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceReferences", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerServiceReferencesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceReferences", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerServiceReferencesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceReferences", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerServiceReferencesPreparer prepares the GetControllerServiceReferences request.
        func (client BaseClient) GetControllerServiceReferencesPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}/references",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerServiceReferencesSender sends the GetControllerServiceReferences request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerServiceReferencesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerServiceReferencesResponder handles the response to the GetControllerServiceReferences request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerServiceReferencesResponder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerServicesFromController sends the get controller services from controller request.
    func (client BaseClient) GetControllerServicesFromController(ctx context.Context) (result ControllerServicesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerServicesFromController")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerServicesFromControllerPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromController", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerServicesFromControllerSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromController", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerServicesFromControllerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromController", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerServicesFromControllerPreparer prepares the GetControllerServicesFromController request.
        func (client BaseClient) GetControllerServicesFromControllerPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/controller/controller-services"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerServicesFromControllerSender sends the GetControllerServicesFromController request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerServicesFromControllerSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerServicesFromControllerResponder handles the response to the GetControllerServicesFromController request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerServicesFromControllerResponder(resp *http.Response) (result ControllerServicesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerServicesFromGroup sends the get controller services from group request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetControllerServicesFromGroup(ctx context.Context, ID string) (result ControllerServicesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerServicesFromGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerServicesFromGroupPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerServicesFromGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromGroup", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerServicesFromGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServicesFromGroup", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerServicesFromGroupPreparer prepares the GetControllerServicesFromGroup request.
        func (client BaseClient) GetControllerServicesFromGroupPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/process-groups/{id}/controller-services",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerServicesFromGroupSender sends the GetControllerServicesFromGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerServicesFromGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerServicesFromGroupResponder handles the response to the GetControllerServicesFromGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerServicesFromGroupResponder(resp *http.Response) (result ControllerServicesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerServiceTypes note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // serviceType - if specified, will only return controller services of this type.
    func (client BaseClient) GetControllerServiceTypes(ctx context.Context, serviceType string) (result ControllerServiceTypesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerServiceTypes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerServiceTypesPreparer(ctx, serviceType)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceTypes", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerServiceTypesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceTypes", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerServiceTypesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerServiceTypes", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerServiceTypesPreparer prepares the GetControllerServiceTypes request.
        func (client BaseClient) GetControllerServiceTypesPreparer(ctx context.Context, serviceType string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(serviceType) > 0 {
                queryParameters["serviceType"] = autorest.Encode("query",serviceType)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/controller-service-types"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerServiceTypesSender sends the GetControllerServiceTypes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerServiceTypesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerServiceTypesResponder handles the response to the GetControllerServiceTypes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerServiceTypesResponder(resp *http.Response) (result ControllerServiceTypesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetControllerStatus sends the get controller status request.
    func (client BaseClient) GetControllerStatus(ctx context.Context) (result ControllerStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetControllerStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetControllerStatusPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetControllerStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetControllerStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetControllerStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetControllerStatusPreparer prepares the GetControllerStatus request.
        func (client BaseClient) GetControllerStatusPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/status"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetControllerStatusSender sends the GetControllerStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetControllerStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetControllerStatusResponder handles the response to the GetControllerStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetControllerStatusResponder(resp *http.Response) (result ControllerStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetCounters note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetCounters(ctx context.Context, nodewise *bool, clusterNodeID string) (result CountersEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetCounters")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetCountersPreparer(ctx, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCounters", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetCountersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCounters", resp, "Failure sending request")
                return
                }

                result, err = client.GetCountersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCounters", resp, "Failure responding to request")
                }

        return
        }

        // GetCountersPreparer prepares the GetCounters request.
        func (client BaseClient) GetCountersPreparer(ctx context.Context, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/counters"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetCountersSender sends the GetCounters request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetCountersSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCountersResponder handles the response to the GetCounters request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetCountersResponder(resp *http.Response) (result CountersEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetCurrentUser sends the get current user request.
    func (client BaseClient) GetCurrentUser(ctx context.Context) (result CurrentUserEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetCurrentUser")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetCurrentUserPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCurrentUser", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetCurrentUserSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCurrentUser", resp, "Failure sending request")
                return
                }

                result, err = client.GetCurrentUserResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetCurrentUser", resp, "Failure responding to request")
                }

        return
        }

        // GetCurrentUserPreparer prepares the GetCurrentUser request.
        func (client BaseClient) GetCurrentUserPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/current-user"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetCurrentUserSender sends the GetCurrentUser request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetCurrentUserSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetCurrentUserResponder handles the response to the GetCurrentUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetCurrentUserResponder(resp *http.Response) (result CurrentUserEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetDropRequest sends the get drop request request.
        // Parameters:
            // ID - the connection id.
            // dropRequestID - the drop request id.
    func (client BaseClient) GetDropRequest(ctx context.Context, ID string, dropRequestID string) (result DropRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetDropRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetDropRequestPreparer(ctx, ID, dropRequestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetDropRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetDropRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetDropRequest", resp, "Failure sending request")
                return
                }

                result, err = client.GetDropRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetDropRequest", resp, "Failure responding to request")
                }

        return
        }

        // GetDropRequestPreparer prepares the GetDropRequest request.
        func (client BaseClient) GetDropRequestPreparer(ctx context.Context, ID string, dropRequestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "drop-request-id": autorest.Encode("path",dropRequestID),
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/drop-requests/{drop-request-id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetDropRequestSender sends the GetDropRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetDropRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetDropRequestResponder handles the response to the GetDropRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetDropRequestResponder(resp *http.Response) (result DropRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFlow sends the get flow request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetFlow(ctx context.Context, ID string) (result ProcessGroupFlowEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFlow")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFlowPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlow", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFlowSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlow", resp, "Failure sending request")
                return
                }

                result, err = client.GetFlowResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlow", resp, "Failure responding to request")
                }

        return
        }

        // GetFlowPreparer prepares the GetFlow request.
        func (client BaseClient) GetFlowPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/process-groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFlowSender sends the GetFlow request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFlowSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFlowResponder handles the response to the GetFlow request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowResponder(resp *http.Response) (result ProcessGroupFlowEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFlowConfig sends the get flow config request.
    func (client BaseClient) GetFlowConfig(ctx context.Context) (result FlowConfigurationEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFlowConfig")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFlowConfigPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowConfig", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFlowConfigSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowConfig", resp, "Failure sending request")
                return
                }

                result, err = client.GetFlowConfigResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowConfig", resp, "Failure responding to request")
                }

        return
        }

        // GetFlowConfigPreparer prepares the GetFlowConfig request.
        func (client BaseClient) GetFlowConfigPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/config"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFlowConfigSender sends the GetFlowConfig request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFlowConfigSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFlowConfigResponder handles the response to the GetFlowConfig request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowConfigResponder(resp *http.Response) (result FlowConfigurationEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFlowFile sends the get flow file request.
        // Parameters:
            // ID - the connection id.
            // flowfileUUID - the flowfile uuid.
            // clusterNodeID - the id of the node where the content exists if clustered.
    func (client BaseClient) GetFlowFile(ctx context.Context, ID string, flowfileUUID string, clusterNodeID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFlowFile")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFlowFilePreparer(ctx, ID, flowfileUUID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowFile", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFlowFileSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowFile", resp, "Failure sending request")
                return
                }

                result, err = client.GetFlowFileResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFlowFile", resp, "Failure responding to request")
                }

        return
        }

        // GetFlowFilePreparer prepares the GetFlowFile request.
        func (client BaseClient) GetFlowFilePreparer(ctx context.Context, ID string, flowfileUUID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "flowfile-uuid": autorest.Encode("path",flowfileUUID),
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/flowfiles/{flowfile-uuid}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFlowFileSender sends the GetFlowFile request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFlowFileSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFlowFileResponder handles the response to the GetFlowFile request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFlowFileResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetFunnel sends the get funnel request.
        // Parameters:
            // ID - the funnel id.
    func (client BaseClient) GetFunnel(ctx context.Context, ID string) (result FunnelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFunnel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFunnelPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnel", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFunnelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnel", resp, "Failure sending request")
                return
                }

                result, err = client.GetFunnelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnel", resp, "Failure responding to request")
                }

        return
        }

        // GetFunnelPreparer prepares the GetFunnel request.
        func (client BaseClient) GetFunnelPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/funnels/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFunnelSender sends the GetFunnel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFunnelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFunnelResponder handles the response to the GetFunnel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFunnelResponder(resp *http.Response) (result FunnelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetFunnels sends the get funnels request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetFunnels(ctx context.Context, ID string) (result FunnelsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetFunnels")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetFunnelsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnels", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetFunnelsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnels", resp, "Failure sending request")
                return
                }

                result, err = client.GetFunnelsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetFunnels", resp, "Failure responding to request")
                }

        return
        }

        // GetFunnelsPreparer prepares the GetFunnels request.
        func (client BaseClient) GetFunnelsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/funnels",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetFunnelsSender sends the GetFunnels request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetFunnelsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetFunnelsResponder handles the response to the GetFunnels request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetFunnelsResponder(resp *http.Response) (result FunnelsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetInputContent sends the get input content request.
        // Parameters:
            // ID - the provenance event id.
            // clusterNodeID - the id of the node where the content exists if clustered.
    func (client BaseClient) GetInputContent(ctx context.Context, ID string, clusterNodeID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetInputContent")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetInputContentPreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputContent", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetInputContentSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputContent", resp, "Failure sending request")
                return
                }

                result, err = client.GetInputContentResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputContent", resp, "Failure responding to request")
                }

        return
        }

        // GetInputContentPreparer prepares the GetInputContent request.
        func (client BaseClient) GetInputContentPreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance-events/{id}/content/input",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetInputContentSender sends the GetInputContent request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetInputContentSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetInputContentResponder handles the response to the GetInputContent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetInputContentResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetInputPort sends the get input port request.
        // Parameters:
            // ID - the input port id.
    func (client BaseClient) GetInputPort(ctx context.Context, ID string) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetInputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetInputPortPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetInputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPort", resp, "Failure sending request")
                return
                }

                result, err = client.GetInputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPort", resp, "Failure responding to request")
                }

        return
        }

        // GetInputPortPreparer prepares the GetInputPort request.
        func (client BaseClient) GetInputPortPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/input-ports/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetInputPortSender sends the GetInputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetInputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetInputPortResponder handles the response to the GetInputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetInputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetInputPorts sends the get input ports request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetInputPorts(ctx context.Context, ID string) (result InputPortsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetInputPorts")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetInputPortsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPorts", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetInputPortsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPorts", resp, "Failure sending request")
                return
                }

                result, err = client.GetInputPortsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPorts", resp, "Failure responding to request")
                }

        return
        }

        // GetInputPortsPreparer prepares the GetInputPorts request.
        func (client BaseClient) GetInputPortsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/input-ports",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetInputPortsSender sends the GetInputPorts request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetInputPortsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetInputPortsResponder handles the response to the GetInputPorts request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetInputPortsResponder(resp *http.Response) (result InputPortsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetInputPortStatus sends the get input port status request.
        // Parameters:
            // ID - the input port id.
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetInputPortStatus(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (result PortStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetInputPortStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetInputPortStatusPreparer(ctx, ID, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPortStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetInputPortStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPortStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetInputPortStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetInputPortStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetInputPortStatusPreparer prepares the GetInputPortStatus request.
        func (client BaseClient) GetInputPortStatusPreparer(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/input-ports/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetInputPortStatusSender sends the GetInputPortStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetInputPortStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetInputPortStatusResponder handles the response to the GetInputPortStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetInputPortStatusResponder(resp *http.Response) (result PortStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetLabel sends the get label request.
        // Parameters:
            // ID - the label id.
    func (client BaseClient) GetLabel(ctx context.Context, ID string) (result LabelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetLabel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetLabelPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabel", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetLabelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabel", resp, "Failure sending request")
                return
                }

                result, err = client.GetLabelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabel", resp, "Failure responding to request")
                }

        return
        }

        // GetLabelPreparer prepares the GetLabel request.
        func (client BaseClient) GetLabelPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/labels/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetLabelSender sends the GetLabel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetLabelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetLabelResponder handles the response to the GetLabel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLabelResponder(resp *http.Response) (result LabelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetLabels sends the get labels request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetLabels(ctx context.Context, ID string) (result LabelsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetLabels")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetLabelsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabels", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetLabelsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabels", resp, "Failure sending request")
                return
                }

                result, err = client.GetLabelsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLabels", resp, "Failure responding to request")
                }

        return
        }

        // GetLabelsPreparer prepares the GetLabels request.
        func (client BaseClient) GetLabelsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/labels",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetLabelsSender sends the GetLabels request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetLabelsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetLabelsResponder handles the response to the GetLabels request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLabelsResponder(resp *http.Response) (result LabelsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetLineage sends the get lineage request.
        // Parameters:
            // ID - the id of the lineage query.
            // clusterNodeID - the id of the node where this query exists if clustered.
    func (client BaseClient) GetLineage(ctx context.Context, ID string, clusterNodeID string) (result LineageEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetLineage")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetLineagePreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLineage", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetLineageSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLineage", resp, "Failure sending request")
                return
                }

                result, err = client.GetLineageResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLineage", resp, "Failure responding to request")
                }

        return
        }

        // GetLineagePreparer prepares the GetLineage request.
        func (client BaseClient) GetLineagePreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance/lineage/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetLineageSender sends the GetLineage request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetLineageSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetLineageResponder handles the response to the GetLineage request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLineageResponder(resp *http.Response) (result LineageEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetListingRequest sends the get listing request request.
        // Parameters:
            // ID - the connection id.
            // listingRequestID - the listing request id.
    func (client BaseClient) GetListingRequest(ctx context.Context, ID string, listingRequestID string) (result ListingRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetListingRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetListingRequestPreparer(ctx, ID, listingRequestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetListingRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetListingRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetListingRequest", resp, "Failure sending request")
                return
                }

                result, err = client.GetListingRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetListingRequest", resp, "Failure responding to request")
                }

        return
        }

        // GetListingRequestPreparer prepares the GetListingRequest request.
        func (client BaseClient) GetListingRequestPreparer(ctx context.Context, ID string, listingRequestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                "listing-request-id": autorest.Encode("path",listingRequestID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/listing-requests/{listing-request-id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetListingRequestSender sends the GetListingRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetListingRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetListingRequestResponder handles the response to the GetListingRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetListingRequestResponder(resp *http.Response) (result ListingRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetLoginConfig sends the get login config request.
    func (client BaseClient) GetLoginConfig(ctx context.Context) (result AccessConfigurationEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetLoginConfig")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetLoginConfigPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLoginConfig", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetLoginConfigSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLoginConfig", resp, "Failure sending request")
                return
                }

                result, err = client.GetLoginConfigResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetLoginConfig", resp, "Failure responding to request")
                }

        return
        }

        // GetLoginConfigPreparer prepares the GetLoginConfig request.
        func (client BaseClient) GetLoginConfigPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/access/config"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetLoginConfigSender sends the GetLoginConfig request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetLoginConfigSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetLoginConfigResponder handles the response to the GetLoginConfig request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetLoginConfigResponder(resp *http.Response) (result AccessConfigurationEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetNode sends the get node request.
        // Parameters:
            // ID - the node id.
    func (client BaseClient) GetNode(ctx context.Context, ID string) (result NodeEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetNode")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetNodePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetNode", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetNodeSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetNode", resp, "Failure sending request")
                return
                }

                result, err = client.GetNodeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetNode", resp, "Failure responding to request")
                }

        return
        }

        // GetNodePreparer prepares the GetNode request.
        func (client BaseClient) GetNodePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller/cluster/nodes/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetNodeSender sends the GetNode request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetNodeSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetNodeResponder handles the response to the GetNode request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetNodeResponder(resp *http.Response) (result NodeEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOutputContent sends the get output content request.
        // Parameters:
            // ID - the provenance event id.
            // clusterNodeID - the id of the node where the content exists if clustered.
    func (client BaseClient) GetOutputContent(ctx context.Context, ID string, clusterNodeID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOutputContent")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOutputContentPreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputContent", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOutputContentSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputContent", resp, "Failure sending request")
                return
                }

                result, err = client.GetOutputContentResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputContent", resp, "Failure responding to request")
                }

        return
        }

        // GetOutputContentPreparer prepares the GetOutputContent request.
        func (client BaseClient) GetOutputContentPreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance-events/{id}/content/output",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOutputContentSender sends the GetOutputContent request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOutputContentSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOutputContentResponder handles the response to the GetOutputContent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOutputContentResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // GetOutputPort sends the get output port request.
        // Parameters:
            // ID - the output port id.
    func (client BaseClient) GetOutputPort(ctx context.Context, ID string) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOutputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOutputPortPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOutputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPort", resp, "Failure sending request")
                return
                }

                result, err = client.GetOutputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPort", resp, "Failure responding to request")
                }

        return
        }

        // GetOutputPortPreparer prepares the GetOutputPort request.
        func (client BaseClient) GetOutputPortPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/output-ports/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOutputPortSender sends the GetOutputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOutputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOutputPortResponder handles the response to the GetOutputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOutputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOutputPorts sends the get output ports request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetOutputPorts(ctx context.Context, ID string) (result OutputPortsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOutputPorts")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOutputPortsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPorts", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOutputPortsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPorts", resp, "Failure sending request")
                return
                }

                result, err = client.GetOutputPortsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPorts", resp, "Failure responding to request")
                }

        return
        }

        // GetOutputPortsPreparer prepares the GetOutputPorts request.
        func (client BaseClient) GetOutputPortsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/output-ports",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOutputPortsSender sends the GetOutputPorts request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOutputPortsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOutputPortsResponder handles the response to the GetOutputPorts request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOutputPortsResponder(resp *http.Response) (result OutputPortsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetOutputPortStatus sends the get output port status request.
        // Parameters:
            // ID - the output port id.
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetOutputPortStatus(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (result PortStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetOutputPortStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetOutputPortStatusPreparer(ctx, ID, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPortStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetOutputPortStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPortStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetOutputPortStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetOutputPortStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetOutputPortStatusPreparer prepares the GetOutputPortStatus request.
        func (client BaseClient) GetOutputPortStatusPreparer(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/output-ports/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetOutputPortStatusSender sends the GetOutputPortStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetOutputPortStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetOutputPortStatusResponder handles the response to the GetOutputPortStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetOutputPortStatusResponder(resp *http.Response) (result PortStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPeers sends the get peers request.
    func (client BaseClient) GetPeers(ctx context.Context) (result PeersEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPeers")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPeersPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPeers", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPeersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPeers", resp, "Failure sending request")
                return
                }

                result, err = client.GetPeersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPeers", resp, "Failure responding to request")
                }

        return
        }

        // GetPeersPreparer prepares the GetPeers request.
        func (client BaseClient) GetPeersPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/site-to-site/peers"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPeersSender sends the GetPeers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPeersSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPeersResponder handles the response to the GetPeers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPeersResponder(resp *http.Response) (result PeersEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPrioritizers note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetPrioritizers(ctx context.Context) (result PrioritizerTypesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPrioritizers")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPrioritizersPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPrioritizers", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPrioritizersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPrioritizers", resp, "Failure sending request")
                return
                }

                result, err = client.GetPrioritizersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPrioritizers", resp, "Failure responding to request")
                }

        return
        }

        // GetPrioritizersPreparer prepares the GetPrioritizers request.
        func (client BaseClient) GetPrioritizersPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/prioritizers"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPrioritizersSender sends the GetPrioritizers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPrioritizersSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPrioritizersResponder handles the response to the GetPrioritizers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPrioritizersResponder(resp *http.Response) (result PrioritizerTypesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessGroup sends the get process group request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetProcessGroup(ctx context.Context, ID string) (result ProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessGroupPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessGroupPreparer prepares the GetProcessGroup request.
        func (client BaseClient) GetProcessGroupPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessGroupSender sends the GetProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessGroupResponder handles the response to the GetProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessGroupResponder(resp *http.Response) (result ProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessGroups sends the get process groups request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetProcessGroups(ctx context.Context, ID string) (result ProcessorsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessGroups")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessGroupsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroups", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessGroupsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroups", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessGroupsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroups", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessGroupsPreparer prepares the GetProcessGroups request.
        func (client BaseClient) GetProcessGroupsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/process-groups",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessGroupsSender sends the GetProcessGroups request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessGroupsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessGroupsResponder handles the response to the GetProcessGroups request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessGroupsResponder(resp *http.Response) (result ProcessorsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessGroupStatus the status for a process group includes status for all descendent components. When invoked on
    // the root group with recursive set to true, it will return the current status of every component in the flow.
        // Parameters:
            // ID - the process group id.
            // recursive - whether all descendant groups and the status of their content will be included. Optional,
            // defaults to false
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetProcessGroupStatus(ctx context.Context, ID string, recursive *bool, nodewise *bool, clusterNodeID string) (result ProcessGroupStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessGroupStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessGroupStatusPreparer(ctx, ID, recursive, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessGroupStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessGroupStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessGroupStatusPreparer prepares the GetProcessGroupStatus request.
        func (client BaseClient) GetProcessGroupStatusPreparer(ctx context.Context, ID string, recursive *bool, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if recursive != nil {
                queryParameters["recursive"] = autorest.Encode("query",*recursive)
                }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/process-groups/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessGroupStatusSender sends the GetProcessGroupStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessGroupStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessGroupStatusResponder handles the response to the GetProcessGroupStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessGroupStatusResponder(resp *http.Response) (result ProcessGroupStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessGroupStatusHistory sends the get process group status history request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetProcessGroupStatusHistory(ctx context.Context, ID string) (result StatusHistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessGroupStatusHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessGroupStatusHistoryPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatusHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessGroupStatusHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatusHistory", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessGroupStatusHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessGroupStatusHistory", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessGroupStatusHistoryPreparer prepares the GetProcessGroupStatusHistory request.
        func (client BaseClient) GetProcessGroupStatusHistoryPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/process-groups/{id}/status/history",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessGroupStatusHistorySender sends the GetProcessGroupStatusHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessGroupStatusHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessGroupStatusHistoryResponder handles the response to the GetProcessGroupStatusHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessGroupStatusHistoryResponder(resp *http.Response) (result StatusHistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessor sends the get processor request.
        // Parameters:
            // ID - the processor id.
    func (client BaseClient) GetProcessor(ctx context.Context, ID string) (result ProcessorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessorPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessor", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessor", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessor", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessorPreparer prepares the GetProcessor request.
        func (client BaseClient) GetProcessorPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessorSender sends the GetProcessor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessorSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessorResponder handles the response to the GetProcessor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessorResponder(resp *http.Response) (result ProcessorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessors sends the get processors request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetProcessors(ctx context.Context, ID string) (result ProcessorsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessors")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessorsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessors", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessorsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessors", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessorsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessors", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessorsPreparer prepares the GetProcessors request.
        func (client BaseClient) GetProcessorsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/processors",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessorsSender sends the GetProcessors request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessorsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessorsResponder handles the response to the GetProcessors request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessorsResponder(resp *http.Response) (result ProcessorsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessorStatus sends the get processor status request.
        // Parameters:
            // ID - the processor id.
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetProcessorStatus(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (result ProcessorStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessorStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessorStatusPreparer(ctx, ID, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessorStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessorStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessorStatusPreparer prepares the GetProcessorStatus request.
        func (client BaseClient) GetProcessorStatusPreparer(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/processors/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessorStatusSender sends the GetProcessorStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessorStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessorStatusResponder handles the response to the GetProcessorStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessorStatusResponder(resp *http.Response) (result ProcessorStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessorStatusHistory sends the get processor status history request.
        // Parameters:
            // ID - the processor id.
    func (client BaseClient) GetProcessorStatusHistory(ctx context.Context, ID string) (result StatusHistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessorStatusHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessorStatusHistoryPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatusHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessorStatusHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatusHistory", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessorStatusHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorStatusHistory", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessorStatusHistoryPreparer prepares the GetProcessorStatusHistory request.
        func (client BaseClient) GetProcessorStatusHistoryPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/processors/{id}/status/history",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessorStatusHistorySender sends the GetProcessorStatusHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessorStatusHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessorStatusHistoryResponder handles the response to the GetProcessorStatusHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessorStatusHistoryResponder(resp *http.Response) (result StatusHistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProcessorTypes note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetProcessorTypes(ctx context.Context) (result ProcessorTypesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProcessorTypes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProcessorTypesPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorTypes", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProcessorTypesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorTypes", resp, "Failure sending request")
                return
                }

                result, err = client.GetProcessorTypesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProcessorTypes", resp, "Failure responding to request")
                }

        return
        }

        // GetProcessorTypesPreparer prepares the GetProcessorTypes request.
        func (client BaseClient) GetProcessorTypesPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/processor-types"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProcessorTypesSender sends the GetProcessorTypes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProcessorTypesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProcessorTypesResponder handles the response to the GetProcessorTypes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProcessorTypesResponder(resp *http.Response) (result ProcessorTypesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPropertyDescriptor sends the get property descriptor request.
        // Parameters:
            // ID - the controller service id.
            // propertyName - the property name to return the descriptor for.
    func (client BaseClient) GetPropertyDescriptor(ctx context.Context, ID string, propertyName string) (result PropertyDescriptorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPropertyDescriptor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPropertyDescriptorPreparer(ctx, ID, propertyName)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPropertyDescriptorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor", resp, "Failure sending request")
                return
                }

                result, err = client.GetPropertyDescriptorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor", resp, "Failure responding to request")
                }

        return
        }

        // GetPropertyDescriptorPreparer prepares the GetPropertyDescriptor request.
        func (client BaseClient) GetPropertyDescriptorPreparer(ctx context.Context, ID string, propertyName string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            "propertyName": autorest.Encode("query",propertyName),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}/descriptors",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPropertyDescriptorSender sends the GetPropertyDescriptor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPropertyDescriptorSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPropertyDescriptorResponder handles the response to the GetPropertyDescriptor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPropertyDescriptorResponder(resp *http.Response) (result PropertyDescriptorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPropertyDescriptor1 sends the get property descriptor 1 request.
        // Parameters:
            // ID - the processor id.
            // propertyName - the property name.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) GetPropertyDescriptor1(ctx context.Context, ID string, propertyName string, clientID string) (result PropertyDescriptorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPropertyDescriptor1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPropertyDescriptor1Preparer(ctx, ID, propertyName, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor1", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPropertyDescriptor1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor1", resp, "Failure sending request")
                return
                }

                result, err = client.GetPropertyDescriptor1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor1", resp, "Failure responding to request")
                }

        return
        }

        // GetPropertyDescriptor1Preparer prepares the GetPropertyDescriptor1 request.
        func (client BaseClient) GetPropertyDescriptor1Preparer(ctx context.Context, ID string, propertyName string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            "propertyName": autorest.Encode("query",propertyName),
            }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}/descriptors",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPropertyDescriptor1Sender sends the GetPropertyDescriptor1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPropertyDescriptor1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPropertyDescriptor1Responder handles the response to the GetPropertyDescriptor1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPropertyDescriptor1Responder(resp *http.Response) (result PropertyDescriptorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetPropertyDescriptor2 sends the get property descriptor 2 request.
        // Parameters:
            // ID - the reporting task id.
            // propertyName - the property name.
    func (client BaseClient) GetPropertyDescriptor2(ctx context.Context, ID string, propertyName string) (result PropertyDescriptorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetPropertyDescriptor2")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetPropertyDescriptor2Preparer(ctx, ID, propertyName)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor2", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetPropertyDescriptor2Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor2", resp, "Failure sending request")
                return
                }

                result, err = client.GetPropertyDescriptor2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetPropertyDescriptor2", resp, "Failure responding to request")
                }

        return
        }

        // GetPropertyDescriptor2Preparer prepares the GetPropertyDescriptor2 request.
        func (client BaseClient) GetPropertyDescriptor2Preparer(ctx context.Context, ID string, propertyName string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            "propertyName": autorest.Encode("query",propertyName),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}/descriptors",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetPropertyDescriptor2Sender sends the GetPropertyDescriptor2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetPropertyDescriptor2Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetPropertyDescriptor2Responder handles the response to the GetPropertyDescriptor2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetPropertyDescriptor2Responder(resp *http.Response) (result PropertyDescriptorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProvenance sends the get provenance request.
        // Parameters:
            // ID - the id of the provenance query.
            // clusterNodeID - the id of the node where this query exists if clustered.
    func (client BaseClient) GetProvenance(ctx context.Context, ID string, clusterNodeID string) (result ProvenanceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProvenance")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProvenancePreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenance", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProvenanceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenance", resp, "Failure sending request")
                return
                }

                result, err = client.GetProvenanceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenance", resp, "Failure responding to request")
                }

        return
        }

        // GetProvenancePreparer prepares the GetProvenance request.
        func (client BaseClient) GetProvenancePreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProvenanceSender sends the GetProvenance request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProvenanceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProvenanceResponder handles the response to the GetProvenance request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProvenanceResponder(resp *http.Response) (result ProvenanceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetProvenanceEvent sends the get provenance event request.
        // Parameters:
            // ID - the provenance event id.
            // clusterNodeID - the id of the node where this event exists if clustered.
    func (client BaseClient) GetProvenanceEvent(ctx context.Context, ID string, clusterNodeID string) (result ProvenanceEventEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetProvenanceEvent")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetProvenanceEventPreparer(ctx, ID, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenanceEvent", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetProvenanceEventSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenanceEvent", resp, "Failure sending request")
                return
                }

                result, err = client.GetProvenanceEventResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetProvenanceEvent", resp, "Failure responding to request")
                }

        return
        }

        // GetProvenanceEventPreparer prepares the GetProvenanceEvent request.
        func (client BaseClient) GetProvenanceEventPreparer(ctx context.Context, ID string, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/provenance-events/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetProvenanceEventSender sends the GetProvenanceEvent request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetProvenanceEventSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetProvenanceEventResponder handles the response to the GetProvenanceEvent request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetProvenanceEventResponder(resp *http.Response) (result ProvenanceEventEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetRemoteProcessGroup sends the get remote process group request.
        // Parameters:
            // ID - the remote process group id.
    func (client BaseClient) GetRemoteProcessGroup(ctx context.Context, ID string) (result RemoteProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetRemoteProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetRemoteProcessGroupPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetRemoteProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.GetRemoteProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // GetRemoteProcessGroupPreparer prepares the GetRemoteProcessGroup request.
        func (client BaseClient) GetRemoteProcessGroupPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/remote-process-groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetRemoteProcessGroupSender sends the GetRemoteProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetRemoteProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRemoteProcessGroupResponder handles the response to the GetRemoteProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetRemoteProcessGroupResponder(resp *http.Response) (result RemoteProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetRemoteProcessGroups sends the get remote process groups request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) GetRemoteProcessGroups(ctx context.Context, ID string) (result RemoteProcessGroupsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetRemoteProcessGroups")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetRemoteProcessGroupsPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroups", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetRemoteProcessGroupsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroups", resp, "Failure sending request")
                return
                }

                result, err = client.GetRemoteProcessGroupsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroups", resp, "Failure responding to request")
                }

        return
        }

        // GetRemoteProcessGroupsPreparer prepares the GetRemoteProcessGroups request.
        func (client BaseClient) GetRemoteProcessGroupsPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/remote-process-groups",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetRemoteProcessGroupsSender sends the GetRemoteProcessGroups request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetRemoteProcessGroupsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRemoteProcessGroupsResponder handles the response to the GetRemoteProcessGroups request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetRemoteProcessGroupsResponder(resp *http.Response) (result RemoteProcessGroupsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetRemoteProcessGroupStatus sends the get remote process group status request.
        // Parameters:
            // ID - the remote process group id.
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetRemoteProcessGroupStatus(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (result ProcessorStatusEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetRemoteProcessGroupStatus")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetRemoteProcessGroupStatusPreparer(ctx, ID, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatus", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetRemoteProcessGroupStatusSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatus", resp, "Failure sending request")
                return
                }

                result, err = client.GetRemoteProcessGroupStatusResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatus", resp, "Failure responding to request")
                }

        return
        }

        // GetRemoteProcessGroupStatusPreparer prepares the GetRemoteProcessGroupStatus request.
        func (client BaseClient) GetRemoteProcessGroupStatusPreparer(ctx context.Context, ID string, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/remote-process-groups/{id}/status",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetRemoteProcessGroupStatusSender sends the GetRemoteProcessGroupStatus request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetRemoteProcessGroupStatusSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRemoteProcessGroupStatusResponder handles the response to the GetRemoteProcessGroupStatus request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetRemoteProcessGroupStatusResponder(resp *http.Response) (result ProcessorStatusEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetRemoteProcessGroupStatusHistory sends the get remote process group status history request.
        // Parameters:
            // ID - the remote process group id.
    func (client BaseClient) GetRemoteProcessGroupStatusHistory(ctx context.Context, ID string) (result StatusHistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetRemoteProcessGroupStatusHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetRemoteProcessGroupStatusHistoryPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatusHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetRemoteProcessGroupStatusHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatusHistory", resp, "Failure sending request")
                return
                }

                result, err = client.GetRemoteProcessGroupStatusHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetRemoteProcessGroupStatusHistory", resp, "Failure responding to request")
                }

        return
        }

        // GetRemoteProcessGroupStatusHistoryPreparer prepares the GetRemoteProcessGroupStatusHistory request.
        func (client BaseClient) GetRemoteProcessGroupStatusHistoryPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/remote-process-groups/{id}/status/history",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetRemoteProcessGroupStatusHistorySender sends the GetRemoteProcessGroupStatusHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetRemoteProcessGroupStatusHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetRemoteProcessGroupStatusHistoryResponder handles the response to the GetRemoteProcessGroupStatusHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetRemoteProcessGroupStatusHistoryResponder(resp *http.Response) (result StatusHistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetReportingTask sends the get reporting task request.
        // Parameters:
            // ID - the reporting task id.
    func (client BaseClient) GetReportingTask(ctx context.Context, ID string) (result ReportingTaskEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetReportingTask")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetReportingTaskPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTask", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetReportingTaskSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTask", resp, "Failure sending request")
                return
                }

                result, err = client.GetReportingTaskResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTask", resp, "Failure responding to request")
                }

        return
        }

        // GetReportingTaskPreparer prepares the GetReportingTask request.
        func (client BaseClient) GetReportingTaskPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetReportingTaskSender sends the GetReportingTask request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetReportingTaskSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetReportingTaskResponder handles the response to the GetReportingTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetReportingTaskResponder(resp *http.Response) (result ReportingTaskEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetReportingTasks sends the get reporting tasks request.
    func (client BaseClient) GetReportingTasks(ctx context.Context) (result ReportingTasksEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetReportingTasks")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetReportingTasksPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTasks", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetReportingTasksSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTasks", resp, "Failure sending request")
                return
                }

                result, err = client.GetReportingTasksResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTasks", resp, "Failure responding to request")
                }

        return
        }

        // GetReportingTasksPreparer prepares the GetReportingTasks request.
        func (client BaseClient) GetReportingTasksPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/reporting-tasks"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetReportingTasksSender sends the GetReportingTasks request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetReportingTasksSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetReportingTasksResponder handles the response to the GetReportingTasks request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetReportingTasksResponder(resp *http.Response) (result ReportingTasksEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetReportingTaskTypes note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetReportingTaskTypes(ctx context.Context) (result ReportingTaskTypesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetReportingTaskTypes")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetReportingTaskTypesPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTaskTypes", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetReportingTaskTypesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTaskTypes", resp, "Failure sending request")
                return
                }

                result, err = client.GetReportingTaskTypesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetReportingTaskTypes", resp, "Failure responding to request")
                }

        return
        }

        // GetReportingTaskTypesPreparer prepares the GetReportingTaskTypes request.
        func (client BaseClient) GetReportingTaskTypesPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/reporting-task-types"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetReportingTaskTypesSender sends the GetReportingTaskTypes request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetReportingTaskTypesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetReportingTaskTypesResponder handles the response to the GetReportingTaskTypes request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetReportingTaskTypesResponder(resp *http.Response) (result ReportingTaskTypesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetResources sends the get resources request.
    func (client BaseClient) GetResources(ctx context.Context) (result ResourcesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetResources")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetResourcesPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetResources", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetResourcesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetResources", resp, "Failure sending request")
                return
                }

                result, err = client.GetResourcesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetResources", resp, "Failure responding to request")
                }

        return
        }

        // GetResourcesPreparer prepares the GetResources request.
        func (client BaseClient) GetResourcesPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/resources"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetResourcesSender sends the GetResources request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetResourcesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetResourcesResponder handles the response to the GetResources request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetResourcesResponder(resp *http.Response) (result ResourcesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusUnauthorized,http.StatusForbidden),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSearchOptions sends the get search options request.
    func (client BaseClient) GetSearchOptions(ctx context.Context) (result ProvenanceOptionsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSearchOptions")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSearchOptionsPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSearchOptions", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSearchOptionsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSearchOptions", resp, "Failure sending request")
                return
                }

                result, err = client.GetSearchOptionsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSearchOptions", resp, "Failure responding to request")
                }

        return
        }

        // GetSearchOptionsPreparer prepares the GetSearchOptions request.
        func (client BaseClient) GetSearchOptionsPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/provenance/search-options"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSearchOptionsSender sends the GetSearchOptions request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSearchOptionsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSearchOptionsResponder handles the response to the GetSearchOptions request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSearchOptionsResponder(resp *http.Response) (result ProvenanceOptionsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSiteToSiteDetails sends the get site to site details request.
    func (client BaseClient) GetSiteToSiteDetails(ctx context.Context) (result ControllerEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSiteToSiteDetails")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSiteToSiteDetailsPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSiteToSiteDetails", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSiteToSiteDetailsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSiteToSiteDetails", resp, "Failure sending request")
                return
                }

                result, err = client.GetSiteToSiteDetailsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSiteToSiteDetails", resp, "Failure responding to request")
                }

        return
        }

        // GetSiteToSiteDetailsPreparer prepares the GetSiteToSiteDetails request.
        func (client BaseClient) GetSiteToSiteDetailsPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/site-to-site"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSiteToSiteDetailsSender sends the GetSiteToSiteDetails request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSiteToSiteDetailsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSiteToSiteDetailsResponder handles the response to the GetSiteToSiteDetails request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSiteToSiteDetailsResponder(resp *http.Response) (result ControllerEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetState sends the get state request.
        // Parameters:
            // ID - the controller service id.
    func (client BaseClient) GetState(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetState")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetStatePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetStateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState", resp, "Failure sending request")
                return
                }

                result, err = client.GetStateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState", resp, "Failure responding to request")
                }

        return
        }

        // GetStatePreparer prepares the GetState request.
        func (client BaseClient) GetStatePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}/state",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetStateSender sends the GetState request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetStateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetStateResponder handles the response to the GetState request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetStateResponder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetState1 sends the get state 1 request.
        // Parameters:
            // ID - the processor id.
    func (client BaseClient) GetState1(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetState1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetState1Preparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState1", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetState1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState1", resp, "Failure sending request")
                return
                }

                result, err = client.GetState1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState1", resp, "Failure responding to request")
                }

        return
        }

        // GetState1Preparer prepares the GetState1 request.
        func (client BaseClient) GetState1Preparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}/state",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetState1Sender sends the GetState1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetState1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetState1Responder handles the response to the GetState1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetState1Responder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetState2 sends the get state 2 request.
        // Parameters:
            // ID - the reporting task id.
    func (client BaseClient) GetState2(ctx context.Context, ID string) (result ComponentStateDTO, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetState2")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetState2Preparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState2", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetState2Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState2", resp, "Failure sending request")
                return
                }

                result, err = client.GetState2Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetState2", resp, "Failure responding to request")
                }

        return
        }

        // GetState2Preparer prepares the GetState2 request.
        func (client BaseClient) GetState2Preparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}/state",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetState2Sender sends the GetState2 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetState2Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetState2Responder handles the response to the GetState2 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetState2Responder(resp *http.Response) (result ComponentStateDTO, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetSystemDiagnostics sends the get system diagnostics request.
        // Parameters:
            // nodewise - whether or not to include the breakdown per node. Optional, defaults to false
            // clusterNodeID - the id of the node where to get the status.
    func (client BaseClient) GetSystemDiagnostics(ctx context.Context, nodewise *bool, clusterNodeID string) (result SystemDiagnosticsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetSystemDiagnostics")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetSystemDiagnosticsPreparer(ctx, nodewise, clusterNodeID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSystemDiagnostics", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetSystemDiagnosticsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSystemDiagnostics", resp, "Failure sending request")
                return
                }

                result, err = client.GetSystemDiagnosticsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetSystemDiagnostics", resp, "Failure responding to request")
                }

        return
        }

        // GetSystemDiagnosticsPreparer prepares the GetSystemDiagnostics request.
        func (client BaseClient) GetSystemDiagnosticsPreparer(ctx context.Context, nodewise *bool, clusterNodeID string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if nodewise != nil {
                queryParameters["nodewise"] = autorest.Encode("query",*nodewise)
                }
                if len(clusterNodeID) > 0 {
                queryParameters["clusterNodeId"] = autorest.Encode("query",clusterNodeID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system-diagnostics"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetSystemDiagnosticsSender sends the GetSystemDiagnostics request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetSystemDiagnosticsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetSystemDiagnosticsResponder handles the response to the GetSystemDiagnostics request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetSystemDiagnosticsResponder(resp *http.Response) (result SystemDiagnosticsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusUnauthorized,http.StatusForbidden),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetTemplates sends the get templates request.
    func (client BaseClient) GetTemplates(ctx context.Context) (result TemplatesEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetTemplates")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetTemplatesPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetTemplates", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetTemplatesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetTemplates", resp, "Failure sending request")
                return
                }

                result, err = client.GetTemplatesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetTemplates", resp, "Failure responding to request")
                }

        return
        }

        // GetTemplatesPreparer prepares the GetTemplates request.
        func (client BaseClient) GetTemplatesPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/templates"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetTemplatesSender sends the GetTemplates request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetTemplatesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetTemplatesResponder handles the response to the GetTemplates request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetTemplatesResponder(resp *http.Response) (result TemplatesEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetUser note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user id.
    func (client BaseClient) GetUser(ctx context.Context, ID string) (result UserEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetUser")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetUserPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUser", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetUserSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUser", resp, "Failure sending request")
                return
                }

                result, err = client.GetUserResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUser", resp, "Failure responding to request")
                }

        return
        }

        // GetUserPreparer prepares the GetUser request.
        func (client BaseClient) GetUserPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/users/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetUserSender sends the GetUser request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetUserSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetUserResponder handles the response to the GetUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserResponder(resp *http.Response) (result UserEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetUserGroup note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user group id.
    func (client BaseClient) GetUserGroup(ctx context.Context, ID string) (result UserGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetUserGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetUserGroupPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetUserGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroup", resp, "Failure sending request")
                return
                }

                result, err = client.GetUserGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroup", resp, "Failure responding to request")
                }

        return
        }

        // GetUserGroupPreparer prepares the GetUserGroup request.
        func (client BaseClient) GetUserGroupPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/user-groups/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetUserGroupSender sends the GetUserGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetUserGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetUserGroupResponder handles the response to the GetUserGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserGroupResponder(resp *http.Response) (result UserGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetUserGroups note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetUserGroups(ctx context.Context) (result UserGroupsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetUserGroups")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetUserGroupsPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroups", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetUserGroupsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroups", resp, "Failure sending request")
                return
                }

                result, err = client.GetUserGroupsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUserGroups", resp, "Failure responding to request")
                }

        return
        }

        // GetUserGroupsPreparer prepares the GetUserGroups request.
        func (client BaseClient) GetUserGroupsPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/tenants/user-groups"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetUserGroupsSender sends the GetUserGroups request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetUserGroupsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetUserGroupsResponder handles the response to the GetUserGroups request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUserGroupsResponder(resp *http.Response) (result UserGroupsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // GetUsers note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) GetUsers(ctx context.Context) (result UsersEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.GetUsers")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.GetUsersPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUsers", nil , "Failure preparing request")
        return
        }

                resp, err := client.GetUsersSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUsers", resp, "Failure sending request")
                return
                }

                result, err = client.GetUsersResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "GetUsers", resp, "Failure responding to request")
                }

        return
        }

        // GetUsersPreparer prepares the GetUsers request.
        func (client BaseClient) GetUsersPreparer(ctx context.Context) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/tenants/users"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // GetUsersSender sends the GetUsers request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) GetUsersSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // GetUsersResponder handles the response to the GetUsers request. The method always
    // closes the http.Response Body.
    func (client BaseClient) GetUsersResponder(resp *http.Response) (result UsersEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ImportTemplate sends the import template request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) ImportTemplate(ctx context.Context, ID string) (result TemplateEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ImportTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ImportTemplatePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ImportTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.ImportTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ImportTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.ImportTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ImportTemplate", resp, "Failure responding to request")
                }

        return
        }

        // ImportTemplatePreparer prepares the ImportTemplate request.
        func (client BaseClient) ImportTemplatePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/templates/import",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ImportTemplateSender sends the ImportTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ImportTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ImportTemplateResponder handles the response to the ImportTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ImportTemplateResponder(resp *http.Response) (result TemplateEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // InstantiateTemplate sends the instantiate template request.
        // Parameters:
            // ID - the process group id.
            // body - the instantiate template request.
    func (client BaseClient) InstantiateTemplate(ctx context.Context, ID string, body InstantiateTemplateRequestEntity) (result FlowEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.InstantiateTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.InstantiateTemplatePreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "InstantiateTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.InstantiateTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "InstantiateTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.InstantiateTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "InstantiateTemplate", resp, "Failure responding to request")
                }

        return
        }

        // InstantiateTemplatePreparer prepares the InstantiateTemplate request.
        func (client BaseClient) InstantiateTemplatePreparer(ctx context.Context, ID string, body InstantiateTemplateRequestEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/template-instance",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // InstantiateTemplateSender sends the InstantiateTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) InstantiateTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // InstantiateTemplateResponder handles the response to the InstantiateTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) InstantiateTemplateResponder(resp *http.Response) (result FlowEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // QueryHistory note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // offset - the offset into the result set.
            // count - the number of actions to return.
            // sortColumn - the field to sort on.
            // sortOrder - the direction to sort.
            // startDate - include actions after this date.
            // endDate - include actions before this date.
            // userIdentity - include actions performed by this user.
            // sourceID - include actions on this component.
    func (client BaseClient) QueryHistory(ctx context.Context, offset string, count string, sortColumn string, sortOrder string, startDate string, endDate string, userIdentity string, sourceID string) (result HistoryEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.QueryHistory")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.QueryHistoryPreparer(ctx, offset, count, sortColumn, sortOrder, startDate, endDate, userIdentity, sourceID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "QueryHistory", nil , "Failure preparing request")
        return
        }

                resp, err := client.QueryHistorySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "QueryHistory", resp, "Failure sending request")
                return
                }

                result, err = client.QueryHistoryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "QueryHistory", resp, "Failure responding to request")
                }

        return
        }

        // QueryHistoryPreparer prepares the QueryHistory request.
        func (client BaseClient) QueryHistoryPreparer(ctx context.Context, offset string, count string, sortColumn string, sortOrder string, startDate string, endDate string, userIdentity string, sourceID string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "count": autorest.Encode("query",count),
            "offset": autorest.Encode("query",offset),
            }
                if len(sortColumn) > 0 {
                queryParameters["sortColumn"] = autorest.Encode("query",sortColumn)
                }
                if len(sortOrder) > 0 {
                queryParameters["sortOrder"] = autorest.Encode("query",sortOrder)
                }
                if len(startDate) > 0 {
                queryParameters["startDate"] = autorest.Encode("query",startDate)
                }
                if len(endDate) > 0 {
                queryParameters["endDate"] = autorest.Encode("query",endDate)
                }
                if len(userIdentity) > 0 {
                queryParameters["userIdentity"] = autorest.Encode("query",userIdentity)
                }
                if len(sourceID) > 0 {
                queryParameters["sourceId"] = autorest.Encode("query",sourceID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/history"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // QueryHistorySender sends the QueryHistory request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) QueryHistorySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // QueryHistoryResponder handles the response to the QueryHistory request. The method always
    // closes the http.Response Body.
    func (client BaseClient) QueryHistoryResponder(resp *http.Response) (result HistoryEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ReceiveFlowFiles sends the receive flow files request.
        // Parameters:
            // portID - the input port id.
    func (client BaseClient) ReceiveFlowFiles(ctx context.Context, portID string, transactionID string) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ReceiveFlowFiles")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ReceiveFlowFilesPreparer(ctx, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ReceiveFlowFiles", nil , "Failure preparing request")
        return
        }

                resp, err := client.ReceiveFlowFilesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ReceiveFlowFiles", resp, "Failure sending request")
                return
                }

                result, err = client.ReceiveFlowFilesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ReceiveFlowFiles", resp, "Failure responding to request")
                }

        return
        }

        // ReceiveFlowFilesPreparer prepares the ReceiveFlowFiles request.
        func (client BaseClient) ReceiveFlowFilesPreparer(ctx context.Context, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/input-ports/{portId}/transactions/{transactionId}/flow-files",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ReceiveFlowFilesSender sends the ReceiveFlowFiles request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ReceiveFlowFilesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ReceiveFlowFilesResponder handles the response to the ReceiveFlowFiles request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ReceiveFlowFilesResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveAccessPolicy sends the remove access policy request.
        // Parameters:
            // ID - the access policy id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveAccessPolicy(ctx context.Context, ID string, version string, clientID string) (result AccessPolicyEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveAccessPolicy")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveAccessPolicyPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveAccessPolicy", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveAccessPolicySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveAccessPolicy", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveAccessPolicyResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveAccessPolicy", resp, "Failure responding to request")
                }

        return
        }

        // RemoveAccessPolicyPreparer prepares the RemoveAccessPolicy request.
        func (client BaseClient) RemoveAccessPolicyPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/policies/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveAccessPolicySender sends the RemoveAccessPolicy request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveAccessPolicySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveAccessPolicyResponder handles the response to the RemoveAccessPolicy request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveAccessPolicyResponder(resp *http.Response) (result AccessPolicyEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveControllerService sends the remove controller service request.
        // Parameters:
            // ID - the controller service id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveControllerService(ctx context.Context, ID string, version string, clientID string) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveControllerService")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveControllerServicePreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveControllerService", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveControllerServiceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveControllerService", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveControllerServiceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveControllerService", resp, "Failure responding to request")
                }

        return
        }

        // RemoveControllerServicePreparer prepares the RemoveControllerService request.
        func (client BaseClient) RemoveControllerServicePreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveControllerServiceSender sends the RemoveControllerService request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveControllerServiceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveControllerServiceResponder handles the response to the RemoveControllerService request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveControllerServiceResponder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveDropRequest sends the remove drop request request.
        // Parameters:
            // ID - the connection id.
            // dropRequestID - the drop request id.
    func (client BaseClient) RemoveDropRequest(ctx context.Context, ID string, dropRequestID string) (result DropRequestEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveDropRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveDropRequestPreparer(ctx, ID, dropRequestID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveDropRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveDropRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveDropRequest", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveDropRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveDropRequest", resp, "Failure responding to request")
                }

        return
        }

        // RemoveDropRequestPreparer prepares the RemoveDropRequest request.
        func (client BaseClient) RemoveDropRequestPreparer(ctx context.Context, ID string, dropRequestID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "drop-request-id": autorest.Encode("path",dropRequestID),
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flowfile-queues/{id}/drop-requests/{drop-request-id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveDropRequestSender sends the RemoveDropRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveDropRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveDropRequestResponder handles the response to the RemoveDropRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveDropRequestResponder(resp *http.Response) (result DropRequestEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveFunnel sends the remove funnel request.
        // Parameters:
            // ID - the funnel id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveFunnel(ctx context.Context, ID string, version string, clientID string) (result FunnelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveFunnel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveFunnelPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveFunnel", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveFunnelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveFunnel", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveFunnelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveFunnel", resp, "Failure responding to request")
                }

        return
        }

        // RemoveFunnelPreparer prepares the RemoveFunnel request.
        func (client BaseClient) RemoveFunnelPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/funnels/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveFunnelSender sends the RemoveFunnel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveFunnelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveFunnelResponder handles the response to the RemoveFunnel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveFunnelResponder(resp *http.Response) (result FunnelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveInputPort sends the remove input port request.
        // Parameters:
            // ID - the input port id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveInputPort(ctx context.Context, ID string, version string, clientID string) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveInputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveInputPortPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveInputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveInputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveInputPort", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveInputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveInputPort", resp, "Failure responding to request")
                }

        return
        }

        // RemoveInputPortPreparer prepares the RemoveInputPort request.
        func (client BaseClient) RemoveInputPortPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/input-ports/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveInputPortSender sends the RemoveInputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveInputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveInputPortResponder handles the response to the RemoveInputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveInputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveLabel sends the remove label request.
        // Parameters:
            // ID - the label id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveLabel(ctx context.Context, ID string, version string, clientID string) (result LabelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveLabel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveLabelPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveLabel", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveLabelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveLabel", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveLabelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveLabel", resp, "Failure responding to request")
                }

        return
        }

        // RemoveLabelPreparer prepares the RemoveLabel request.
        func (client BaseClient) RemoveLabelPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/labels/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveLabelSender sends the RemoveLabel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveLabelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveLabelResponder handles the response to the RemoveLabel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveLabelResponder(resp *http.Response) (result LabelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveOutputPort sends the remove output port request.
        // Parameters:
            // ID - the output port id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveOutputPort(ctx context.Context, ID string, version string, clientID string) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveOutputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveOutputPortPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveOutputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveOutputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveOutputPort", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveOutputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveOutputPort", resp, "Failure responding to request")
                }

        return
        }

        // RemoveOutputPortPreparer prepares the RemoveOutputPort request.
        func (client BaseClient) RemoveOutputPortPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/output-ports/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveOutputPortSender sends the RemoveOutputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveOutputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveOutputPortResponder handles the response to the RemoveOutputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveOutputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveProcessGroup sends the remove process group request.
        // Parameters:
            // ID - the process group id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveProcessGroup(ctx context.Context, ID string, version string, clientID string) (result ProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveProcessGroupPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // RemoveProcessGroupPreparer prepares the RemoveProcessGroup request.
        func (client BaseClient) RemoveProcessGroupPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveProcessGroupSender sends the RemoveProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveProcessGroupResponder handles the response to the RemoveProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveProcessGroupResponder(resp *http.Response) (result ProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveRemoteProcessGroup sends the remove remote process group request.
        // Parameters:
            // ID - the remote process group id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveRemoteProcessGroup(ctx context.Context, ID string, version string, clientID string) (result RemoteProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveRemoteProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveRemoteProcessGroupPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveRemoteProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveRemoteProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveRemoteProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveRemoteProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveRemoteProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // RemoveRemoteProcessGroupPreparer prepares the RemoveRemoteProcessGroup request.
        func (client BaseClient) RemoveRemoteProcessGroupPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/remote-process-groups/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveRemoteProcessGroupSender sends the RemoveRemoteProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveRemoteProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveRemoteProcessGroupResponder handles the response to the RemoveRemoteProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveRemoteProcessGroupResponder(resp *http.Response) (result RemoteProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveReportingTask sends the remove reporting task request.
        // Parameters:
            // ID - the reporting task id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveReportingTask(ctx context.Context, ID string, version string, clientID string) (result ReportingTaskEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveReportingTask")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveReportingTaskPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveReportingTask", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveReportingTaskSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveReportingTask", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveReportingTaskResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveReportingTask", resp, "Failure responding to request")
                }

        return
        }

        // RemoveReportingTaskPreparer prepares the RemoveReportingTask request.
        func (client BaseClient) RemoveReportingTaskPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveReportingTaskSender sends the RemoveReportingTask request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveReportingTaskSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveReportingTaskResponder handles the response to the RemoveReportingTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveReportingTaskResponder(resp *http.Response) (result ReportingTaskEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveTemplate sends the remove template request.
        // Parameters:
            // ID - the template id.
    func (client BaseClient) RemoveTemplate(ctx context.Context, ID string) (result TemplateEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveTemplatePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveTemplate", resp, "Failure responding to request")
                }

        return
        }

        // RemoveTemplatePreparer prepares the RemoveTemplate request.
        func (client BaseClient) RemoveTemplatePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/templates/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveTemplateSender sends the RemoveTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveTemplateResponder handles the response to the RemoveTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveTemplateResponder(resp *http.Response) (result TemplateEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveUser note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveUser(ctx context.Context, ID string, version string, clientID string) (result UserEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveUser")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveUserPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUser", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveUserSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUser", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveUserResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUser", resp, "Failure responding to request")
                }

        return
        }

        // RemoveUserPreparer prepares the RemoveUser request.
        func (client BaseClient) RemoveUserPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/users/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveUserSender sends the RemoveUser request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveUserSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveUserResponder handles the response to the RemoveUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveUserResponder(resp *http.Response) (result UserEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // RemoveUserGroup note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user group id.
            // version - the revision is used to verify the client is working with the latest version of the flow.
            // clientID - if the client id is not specified, new one will be generated. This value (whether specified or
            // generated) is included in the response.
    func (client BaseClient) RemoveUserGroup(ctx context.Context, ID string, version string, clientID string) (result UserGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.RemoveUserGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.RemoveUserGroupPreparer(ctx, ID, version, clientID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUserGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.RemoveUserGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUserGroup", resp, "Failure sending request")
                return
                }

                result, err = client.RemoveUserGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "RemoveUserGroup", resp, "Failure responding to request")
                }

        return
        }

        // RemoveUserGroupPreparer prepares the RemoveUserGroup request.
        func (client BaseClient) RemoveUserGroupPreparer(ctx context.Context, ID string, version string, clientID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(version) > 0 {
                queryParameters["version"] = autorest.Encode("query",version)
                }
                if len(clientID) > 0 {
                queryParameters["clientId"] = autorest.Encode("query",clientID)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/user-groups/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // RemoveUserGroupSender sends the RemoveUserGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) RemoveUserGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // RemoveUserGroupResponder handles the response to the RemoveUserGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) RemoveUserGroupResponder(resp *http.Response) (result UserGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ScheduleComponents sends the schedule components request.
        // Parameters:
            // ID - the process group id.
            // body - the request to schedule or unschedule. If the comopnents in the request are not specified, all
            // authorized components will be considered.
    func (client BaseClient) ScheduleComponents(ctx context.Context, ID string, body ScheduleComponentsEntity) (result ScheduleComponentsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ScheduleComponents")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ScheduleComponentsPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ScheduleComponents", nil , "Failure preparing request")
        return
        }

                resp, err := client.ScheduleComponentsSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ScheduleComponents", resp, "Failure sending request")
                return
                }

                result, err = client.ScheduleComponentsResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "ScheduleComponents", resp, "Failure responding to request")
                }

        return
        }

        // ScheduleComponentsPreparer prepares the ScheduleComponents request.
        func (client BaseClient) ScheduleComponentsPreparer(ctx context.Context, ID string, body ScheduleComponentsEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/flow/process-groups/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ScheduleComponentsSender sends the ScheduleComponents request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ScheduleComponentsSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ScheduleComponentsResponder handles the response to the ScheduleComponents request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ScheduleComponentsResponder(resp *http.Response) (result ScheduleComponentsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SearchCluster note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // q - node address to search for.
    func (client BaseClient) SearchCluster(ctx context.Context, q string) (result ClusterSearchResultsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SearchCluster")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SearchClusterPreparer(ctx, q)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster", nil , "Failure preparing request")
        return
        }

                resp, err := client.SearchClusterSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster", resp, "Failure sending request")
                return
                }

                result, err = client.SearchClusterResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster", resp, "Failure responding to request")
                }

        return
        }

        // SearchClusterPreparer prepares the SearchCluster request.
        func (client BaseClient) SearchClusterPreparer(ctx context.Context, q string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "q": autorest.Encode("query",q),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/cluster/search-results"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SearchClusterSender sends the SearchCluster request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SearchClusterSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SearchClusterResponder handles the response to the SearchCluster request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SearchClusterResponder(resp *http.Response) (result ClusterSearchResultsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SearchCluster1 note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // q - node address to search for.
    func (client BaseClient) SearchCluster1(ctx context.Context, q string) (result ClusterSearchResultsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SearchCluster1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SearchCluster1Preparer(ctx, q)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster1", nil , "Failure preparing request")
        return
        }

                resp, err := client.SearchCluster1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster1", resp, "Failure sending request")
                return
                }

                result, err = client.SearchCluster1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchCluster1", resp, "Failure responding to request")
                }

        return
        }

        // SearchCluster1Preparer prepares the SearchCluster1 request.
        func (client BaseClient) SearchCluster1Preparer(ctx context.Context, q string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            "q": autorest.Encode("query",q),
            }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/tenants/search-results"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SearchCluster1Sender sends the SearchCluster1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SearchCluster1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SearchCluster1Responder handles the response to the SearchCluster1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SearchCluster1Responder(resp *http.Response) (result ClusterSearchResultsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SearchFlow only search results from authorized components will be returned.
    func (client BaseClient) SearchFlow(ctx context.Context, q string) (result SearchResultsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SearchFlow")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SearchFlowPreparer(ctx, q)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchFlow", nil , "Failure preparing request")
        return
        }

                resp, err := client.SearchFlowSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchFlow", resp, "Failure sending request")
                return
                }

                result, err = client.SearchFlowResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SearchFlow", resp, "Failure responding to request")
                }

        return
        }

        // SearchFlowPreparer prepares the SearchFlow request.
        func (client BaseClient) SearchFlowPreparer(ctx context.Context, q string) (*http.Request, error) {
                    queryParameters := map[string]interface{} {
            }
                if len(q) > 0 {
                queryParameters["q"] = autorest.Encode("query",q)
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/flow/search-results"),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SearchFlowSender sends the SearchFlow request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SearchFlowSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SearchFlowResponder handles the response to the SearchFlow request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SearchFlowResponder(resp *http.Response) (result SearchResultsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SubmitLineageRequest lineage queries may be long running so this endpoint submits a request. The response will
    // include the current state of the query. If the request is not completed the URI in the response can be used at a
    // later time to get the updated state of the query. Once the query has completed the lineage request should be deleted
    // by the client who originally submitted it.
        // Parameters:
            // body - the lineage query details.
    func (client BaseClient) SubmitLineageRequest(ctx context.Context, body LineageEntity) (result LineageEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubmitLineageRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Lineage", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Lineage.Results", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Lineage.Results.Errors", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Lineage.Results.Errors", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "SubmitLineageRequest", err.Error())
                }

                    req, err := client.SubmitLineageRequestPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitLineageRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubmitLineageRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitLineageRequest", resp, "Failure sending request")
                return
                }

                result, err = client.SubmitLineageRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitLineageRequest", resp, "Failure responding to request")
                }

        return
        }

        // SubmitLineageRequestPreparer prepares the SubmitLineageRequest request.
        func (client BaseClient) SubmitLineageRequestPreparer(ctx context.Context, body LineageEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/provenance/lineage"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubmitLineageRequestSender sends the SubmitLineageRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubmitLineageRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SubmitLineageRequestResponder handles the response to the SubmitLineageRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubmitLineageRequestResponder(resp *http.Response) (result LineageEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SubmitProvenanceRequest provenance queries may be long running so this endpoint submits a request. The response will
    // include the current state of the query. If the request is not completed the URI in the response can be used at a
    // later time to get the updated state of the query. Once the query has completed the provenance request should be
    // deleted by the client who originally submitted it.
        // Parameters:
            // body - the provenance query details.
    func (client BaseClient) SubmitProvenanceRequest(ctx context.Context, body ProvenanceEntity) (result ProvenanceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubmitProvenanceRequest")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Provenance", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Provenance.Results", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Provenance.Results.Errors", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Provenance.Results.Errors", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "SubmitProvenanceRequest", err.Error())
                }

                    req, err := client.SubmitProvenanceRequestPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitProvenanceRequest", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubmitProvenanceRequestSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitProvenanceRequest", resp, "Failure sending request")
                return
                }

                result, err = client.SubmitProvenanceRequestResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitProvenanceRequest", resp, "Failure responding to request")
                }

        return
        }

        // SubmitProvenanceRequestPreparer prepares the SubmitProvenanceRequest request.
        func (client BaseClient) SubmitProvenanceRequestPreparer(ctx context.Context, body ProvenanceEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/provenance"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubmitProvenanceRequestSender sends the SubmitProvenanceRequest request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubmitProvenanceRequestSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SubmitProvenanceRequestResponder handles the response to the SubmitProvenanceRequest request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubmitProvenanceRequestResponder(resp *http.Response) (result ProvenanceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SubmitReplay sends the submit replay request.
        // Parameters:
            // body - the replay request.
    func (client BaseClient) SubmitReplay(ctx context.Context, body SubmitReplayRequestEntity) (result ProvenanceEventEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SubmitReplay")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SubmitReplayPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitReplay", nil , "Failure preparing request")
        return
        }

                resp, err := client.SubmitReplaySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitReplay", resp, "Failure sending request")
                return
                }

                result, err = client.SubmitReplayResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "SubmitReplay", resp, "Failure responding to request")
                }

        return
        }

        // SubmitReplayPreparer prepares the SubmitReplay request.
        func (client BaseClient) SubmitReplayPreparer(ctx context.Context, body SubmitReplayRequestEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/provenance-events/replays"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SubmitReplaySender sends the SubmitReplay request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SubmitReplaySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SubmitReplayResponder handles the response to the SubmitReplay request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SubmitReplayResponder(resp *http.Response) (result ProvenanceEventEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // TransferFlowFiles sends the transfer flow files request.
        // Parameters:
            // portID - the output port id.
    func (client BaseClient) TransferFlowFiles(ctx context.Context, portID string, transactionID string) (result SetObject, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.TransferFlowFiles")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.TransferFlowFilesPreparer(ctx, portID, transactionID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "TransferFlowFiles", nil , "Failure preparing request")
        return
        }

                resp, err := client.TransferFlowFilesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "TransferFlowFiles", resp, "Failure sending request")
                return
                }

                result, err = client.TransferFlowFilesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "TransferFlowFiles", resp, "Failure responding to request")
                }

        return
        }

        // TransferFlowFilesPreparer prepares the TransferFlowFiles request.
        func (client BaseClient) TransferFlowFilesPreparer(ctx context.Context, portID string, transactionID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "portId": autorest.Encode("path",portID),
                "transactionId": autorest.Encode("path",transactionID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/data-transfer/output-ports/{portId}/transactions/{transactionId}/flow-files",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // TransferFlowFilesSender sends the TransferFlowFiles request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) TransferFlowFilesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // TransferFlowFilesResponder handles the response to the TransferFlowFiles request. The method always
    // closes the http.Response Body.
    func (client BaseClient) TransferFlowFilesResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict,http.StatusServiceUnavailable),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateAccessPolicy sends the update access policy request.
        // Parameters:
            // ID - the access policy id.
            // body - the access policy configuration details.
    func (client BaseClient) UpdateAccessPolicy(ctx context.Context, ID string, body AccessPolicyEntity) (result AccessPolicyEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateAccessPolicy")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.UserGroups", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateAccessPolicy", err.Error())
                }

                    req, err := client.UpdateAccessPolicyPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateAccessPolicy", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateAccessPolicySender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateAccessPolicy", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateAccessPolicyResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateAccessPolicy", resp, "Failure responding to request")
                }

        return
        }

        // UpdateAccessPolicyPreparer prepares the UpdateAccessPolicy request.
        func (client BaseClient) UpdateAccessPolicyPreparer(ctx context.Context, ID string, body AccessPolicyEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/policies/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateAccessPolicySender sends the UpdateAccessPolicy request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateAccessPolicySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateAccessPolicyResponder handles the response to the UpdateAccessPolicy request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateAccessPolicyResponder(resp *http.Response) (result AccessPolicyEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateConnection sends the update connection request.
        // Parameters:
            // ID - the connection id.
            // body - the connection configuration details.
    func (client BaseClient) UpdateConnection(ctx context.Context, ID string, body ConnectionEntity) (result ConnectionEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateConnection")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Source", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Source.ID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "body.Component.Source.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.Destination", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Destination.ID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "body.Component.Destination.GroupID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.SelectedRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.SelectedRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AvailableRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AvailableRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateConnection", err.Error())
                }

                    req, err := client.UpdateConnectionPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateConnection", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateConnectionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateConnection", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateConnectionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateConnection", resp, "Failure responding to request")
                }

        return
        }

        // UpdateConnectionPreparer prepares the UpdateConnection request.
        func (client BaseClient) UpdateConnectionPreparer(ctx context.Context, ID string, body ConnectionEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/connections/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateConnectionSender sends the UpdateConnection request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateConnectionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateConnectionResponder handles the response to the UpdateConnection request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateConnectionResponder(resp *http.Response) (result ConnectionEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateControllerConfig sends the update controller config request.
        // Parameters:
            // body - the controller configuration.
    func (client BaseClient) UpdateControllerConfig(ctx context.Context, body ControllerConfigurationEntity) (result ControllerConfigurationEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateControllerConfig")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateControllerConfigPreparer(ctx, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerConfig", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateControllerConfigSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerConfig", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateControllerConfigResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerConfig", resp, "Failure responding to request")
                }

        return
        }

        // UpdateControllerConfigPreparer prepares the UpdateControllerConfig request.
        func (client BaseClient) UpdateControllerConfigPreparer(ctx context.Context, body ControllerConfigurationEntity) (*http.Request, error) {
        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/controller/config"),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateControllerConfigSender sends the UpdateControllerConfig request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateControllerConfigSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateControllerConfigResponder handles the response to the UpdateControllerConfig request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateControllerConfigResponder(resp *http.Response) (result ControllerConfigurationEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateControllerService sends the update controller service request.
        // Parameters:
            // ID - the controller service id.
            // body - the controller service configuration details.
    func (client BaseClient) UpdateControllerService(ctx context.Context, ID string, body ControllerServiceEntity) (result ControllerServiceEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateControllerService")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.ReferencingComponents", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateControllerService", err.Error())
                }

                    req, err := client.UpdateControllerServicePreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerService", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateControllerServiceSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerService", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateControllerServiceResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerService", resp, "Failure responding to request")
                }

        return
        }

        // UpdateControllerServicePreparer prepares the UpdateControllerService request.
        func (client BaseClient) UpdateControllerServicePreparer(ctx context.Context, ID string, body ControllerServiceEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateControllerServiceSender sends the UpdateControllerService request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateControllerServiceSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateControllerServiceResponder handles the response to the UpdateControllerService request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateControllerServiceResponder(resp *http.Response) (result ControllerServiceEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateControllerServiceReferences sends the update controller service references request.
        // Parameters:
            // ID - the controller service id.
            // body - the controller service request update request.
    func (client BaseClient) UpdateControllerServiceReferences(ctx context.Context, ID string, body UpdateControllerServiceReferenceRequestEntity) (result ControllerServiceReferencingComponentsEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateControllerServiceReferences")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateControllerServiceReferencesPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerServiceReferences", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateControllerServiceReferencesSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerServiceReferences", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateControllerServiceReferencesResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateControllerServiceReferences", resp, "Failure responding to request")
                }

        return
        }

        // UpdateControllerServiceReferencesPreparer prepares the UpdateControllerServiceReferences request.
        func (client BaseClient) UpdateControllerServiceReferencesPreparer(ctx context.Context, ID string, body UpdateControllerServiceReferenceRequestEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller-services/{id}/references",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateControllerServiceReferencesSender sends the UpdateControllerServiceReferences request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateControllerServiceReferencesSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateControllerServiceReferencesResponder handles the response to the UpdateControllerServiceReferences request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateControllerServiceReferencesResponder(resp *http.Response) (result ControllerServiceReferencingComponentsEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateCounter note: This endpoint is subject to change as NiFi and it's REST API evolve.
    func (client BaseClient) UpdateCounter(ctx context.Context, ID string) (result CounterEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateCounter")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateCounterPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateCounter", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateCounterSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateCounter", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateCounterResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateCounter", resp, "Failure responding to request")
                }

        return
        }

        // UpdateCounterPreparer prepares the UpdateCounter request.
        func (client BaseClient) UpdateCounterPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/counters/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateCounterSender sends the UpdateCounter request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateCounterSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateCounterResponder handles the response to the UpdateCounter request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateCounterResponder(resp *http.Response) (result CounterEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateFunnel sends the update funnel request.
        // Parameters:
            // ID - the funnel id.
            // body - the funnel configuration details.
    func (client BaseClient) UpdateFunnel(ctx context.Context, ID string, body FunnelEntity) (result FunnelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateFunnel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateFunnelPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateFunnel", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateFunnelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateFunnel", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateFunnelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateFunnel", resp, "Failure responding to request")
                }

        return
        }

        // UpdateFunnelPreparer prepares the UpdateFunnel request.
        func (client BaseClient) UpdateFunnelPreparer(ctx context.Context, ID string, body FunnelEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/funnels/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateFunnelSender sends the UpdateFunnel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateFunnelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateFunnelResponder handles the response to the UpdateFunnel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateFunnelResponder(resp *http.Response) (result FunnelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateInputPort sends the update input port request.
        // Parameters:
            // ID - the input port id.
            // body - the input port configuration details.
    func (client BaseClient) UpdateInputPort(ctx context.Context, ID string, body PortEntity) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateInputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.GroupAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.GroupAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateInputPort", err.Error())
                }

                    req, err := client.UpdateInputPortPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateInputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateInputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateInputPort", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateInputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateInputPort", resp, "Failure responding to request")
                }

        return
        }

        // UpdateInputPortPreparer prepares the UpdateInputPort request.
        func (client BaseClient) UpdateInputPortPreparer(ctx context.Context, ID string, body PortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/input-ports/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateInputPortSender sends the UpdateInputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateInputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateInputPortResponder handles the response to the UpdateInputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateInputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateLabel sends the update label request.
        // Parameters:
            // ID - the label id.
            // body - the label configuraiton details.
    func (client BaseClient) UpdateLabel(ctx context.Context, ID string, body LabelEntity) (result LabelEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateLabel")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateLabelPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateLabel", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateLabelSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateLabel", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateLabelResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateLabel", resp, "Failure responding to request")
                }

        return
        }

        // UpdateLabelPreparer prepares the UpdateLabel request.
        func (client BaseClient) UpdateLabelPreparer(ctx context.Context, ID string, body LabelEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/labels/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateLabelSender sends the UpdateLabel request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateLabelSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateLabelResponder handles the response to the UpdateLabel request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateLabelResponder(resp *http.Response) (result LabelEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateNode sends the update node request.
        // Parameters:
            // ID - the node id.
            // body - the node configuration. The only configuration that will be honored at this endpoint is the status or
            // primary flag.
    func (client BaseClient) UpdateNode(ctx context.Context, ID string, body NodeEntity) (result NodeEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateNode")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Node", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Node.Roles", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Node.Roles", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateNode", err.Error())
                }

                    req, err := client.UpdateNodePreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateNode", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateNodeSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateNode", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateNodeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateNode", resp, "Failure responding to request")
                }

        return
        }

        // UpdateNodePreparer prepares the UpdateNode request.
        func (client BaseClient) UpdateNodePreparer(ctx context.Context, ID string, body NodeEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/controller/cluster/nodes/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateNodeSender sends the UpdateNode request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateNodeSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateNodeResponder handles the response to the UpdateNode request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateNodeResponder(resp *http.Response) (result NodeEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateOutputPort sends the update output port request.
        // Parameters:
            // ID - the output port id.
            // body - the output port configuration details.
    func (client BaseClient) UpdateOutputPort(ctx context.Context, ID string, body PortEntity) (result PortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateOutputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.GroupAccessControl", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.GroupAccessControl", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateOutputPort", err.Error())
                }

                    req, err := client.UpdateOutputPortPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateOutputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateOutputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateOutputPort", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateOutputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateOutputPort", resp, "Failure responding to request")
                }

        return
        }

        // UpdateOutputPortPreparer prepares the UpdateOutputPort request.
        func (client BaseClient) UpdateOutputPortPreparer(ctx context.Context, ID string, body PortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/output-ports/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateOutputPortSender sends the UpdateOutputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateOutputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateOutputPortResponder handles the response to the UpdateOutputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateOutputPortResponder(resp *http.Response) (result PortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateProcessGroup sends the update process group request.
        // Parameters:
            // ID - the process group id.
            // body - the process group configuration details.
    func (client BaseClient) UpdateProcessGroup(ctx context.Context, ID string, body ProcessGroupEntity) (result ProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateProcessGroupPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // UpdateProcessGroupPreparer prepares the UpdateProcessGroup request.
        func (client BaseClient) UpdateProcessGroupPreparer(ctx context.Context, ID string, body ProcessGroupEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateProcessGroupSender sends the UpdateProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateProcessGroupResponder handles the response to the UpdateProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateProcessGroupResponder(resp *http.Response) (result ProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateProcessor sends the update processor request.
        // Parameters:
            // ID - the processor id.
            // body - the processor configuration details.
    func (client BaseClient) UpdateProcessor(ctx context.Context, ID string, body ProcessorEntity) (result ProcessorEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateProcessor")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config.AutoTerminatedRelationships", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Config.AutoTerminatedRelationships", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateProcessor", err.Error())
                }

                    req, err := client.UpdateProcessorPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessor", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateProcessorSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessor", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateProcessorResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateProcessor", resp, "Failure responding to request")
                }

        return
        }

        // UpdateProcessorPreparer prepares the UpdateProcessor request.
        func (client BaseClient) UpdateProcessorPreparer(ctx context.Context, ID string, body ProcessorEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/processors/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateProcessorSender sends the UpdateProcessor request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateProcessorSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateProcessorResponder handles the response to the UpdateProcessor request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateProcessorResponder(resp *http.Response) (result ProcessorEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateRemoteProcessGroup sends the update remote process group request.
        // Parameters:
            // ID - the remote process group id.
            // body - the remote process group.
    func (client BaseClient) UpdateRemoteProcessGroup(ctx context.Context, ID string, body RemoteProcessGroupEntity) (result RemoteProcessGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateRemoteProcessGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.InputPorts", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.InputPorts", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.Contents.OutputPorts", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Contents.OutputPorts", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateRemoteProcessGroup", err.Error())
                }

                    req, err := client.UpdateRemoteProcessGroupPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateRemoteProcessGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroup", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateRemoteProcessGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroup", resp, "Failure responding to request")
                }

        return
        }

        // UpdateRemoteProcessGroupPreparer prepares the UpdateRemoteProcessGroup request.
        func (client BaseClient) UpdateRemoteProcessGroupPreparer(ctx context.Context, ID string, body RemoteProcessGroupEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/remote-process-groups/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateRemoteProcessGroupSender sends the UpdateRemoteProcessGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateRemoteProcessGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateRemoteProcessGroupResponder handles the response to the UpdateRemoteProcessGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateRemoteProcessGroupResponder(resp *http.Response) (result RemoteProcessGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateRemoteProcessGroupInputPort note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the remote process group id.
            // portID - the remote process group port id.
            // body - the remote process group port.
    func (client BaseClient) UpdateRemoteProcessGroupInputPort(ctx context.Context, ID string, portID string, body RemoteProcessGroupPortEntity) (result RemoteProcessGroupPortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateRemoteProcessGroupInputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateRemoteProcessGroupInputPortPreparer(ctx, ID, portID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupInputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateRemoteProcessGroupInputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupInputPort", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateRemoteProcessGroupInputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupInputPort", resp, "Failure responding to request")
                }

        return
        }

        // UpdateRemoteProcessGroupInputPortPreparer prepares the UpdateRemoteProcessGroupInputPort request.
        func (client BaseClient) UpdateRemoteProcessGroupInputPortPreparer(ctx context.Context, ID string, portID string, body RemoteProcessGroupPortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                "port-id": autorest.Encode("path",portID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/remote-process-groups/{id}/input-ports/{port-id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateRemoteProcessGroupInputPortSender sends the UpdateRemoteProcessGroupInputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateRemoteProcessGroupInputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateRemoteProcessGroupInputPortResponder handles the response to the UpdateRemoteProcessGroupInputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateRemoteProcessGroupInputPortResponder(resp *http.Response) (result RemoteProcessGroupPortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateRemoteProcessGroupOutputPort note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the remote process group id.
            // portID - the remote process group port id.
            // body - the remote process group port.
    func (client BaseClient) UpdateRemoteProcessGroupOutputPort(ctx context.Context, ID string, portID string, body RemoteProcessGroupPortEntity) (result RemoteProcessGroupPortEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateRemoteProcessGroupOutputPort")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateRemoteProcessGroupOutputPortPreparer(ctx, ID, portID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupOutputPort", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateRemoteProcessGroupOutputPortSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupOutputPort", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateRemoteProcessGroupOutputPortResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateRemoteProcessGroupOutputPort", resp, "Failure responding to request")
                }

        return
        }

        // UpdateRemoteProcessGroupOutputPortPreparer prepares the UpdateRemoteProcessGroupOutputPort request.
        func (client BaseClient) UpdateRemoteProcessGroupOutputPortPreparer(ctx context.Context, ID string, portID string, body RemoteProcessGroupPortEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                "port-id": autorest.Encode("path",portID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/remote-process-groups/{id}/output-ports/{port-id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateRemoteProcessGroupOutputPortSender sends the UpdateRemoteProcessGroupOutputPort request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateRemoteProcessGroupOutputPortSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateRemoteProcessGroupOutputPortResponder handles the response to the UpdateRemoteProcessGroupOutputPort request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateRemoteProcessGroupOutputPortResponder(resp *http.Response) (result RemoteProcessGroupPortEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateReportingTask sends the update reporting task request.
        // Parameters:
            // ID - the reporting task id.
            // body - the reporting task configuration details.
    func (client BaseClient) UpdateReportingTask(ctx context.Context, ID string, body ReportingTaskEntity) (result ReportingTaskEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateReportingTask")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateReportingTaskPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateReportingTask", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateReportingTaskSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateReportingTask", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateReportingTaskResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateReportingTask", resp, "Failure responding to request")
                }

        return
        }

        // UpdateReportingTaskPreparer prepares the UpdateReportingTask request.
        func (client BaseClient) UpdateReportingTaskPreparer(ctx context.Context, ID string, body ReportingTaskEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/reporting-tasks/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateReportingTaskSender sends the UpdateReportingTask request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateReportingTaskSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateReportingTaskResponder handles the response to the UpdateReportingTask request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateReportingTaskResponder(resp *http.Response) (result ReportingTaskEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateSnippet sends the update snippet request.
        // Parameters:
            // ID - the snippet id.
            // body - the snippet configuration details.
    func (client BaseClient) UpdateSnippet(ctx context.Context, ID string, body SnippetEntity) (result SnippetEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateSnippet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UpdateSnippetPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateSnippet", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateSnippetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateSnippet", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateSnippetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateSnippet", resp, "Failure responding to request")
                }

        return
        }

        // UpdateSnippetPreparer prepares the UpdateSnippet request.
        func (client BaseClient) UpdateSnippetPreparer(ctx context.Context, ID string, body SnippetEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/snippets/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateSnippetSender sends the UpdateSnippet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateSnippetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateSnippetResponder handles the response to the UpdateSnippet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateSnippetResponder(resp *http.Response) (result SnippetEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateUser note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user id.
            // body - the user configuration details.
    func (client BaseClient) UpdateUser(ctx context.Context, ID string, body UserEntity) (result UserEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateUser")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.UserGroups", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AccessPolicies", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AccessPolicies", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateUser", err.Error())
                }

                    req, err := client.UpdateUserPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUser", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateUserSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUser", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateUserResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUser", resp, "Failure responding to request")
                }

        return
        }

        // UpdateUserPreparer prepares the UpdateUser request.
        func (client BaseClient) UpdateUserPreparer(ctx context.Context, ID string, body UserEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/users/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateUserSender sends the UpdateUser request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateUserSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateUserResponder handles the response to the UpdateUser request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateUserResponder(resp *http.Response) (result UserEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UpdateUserGroup note: This endpoint is subject to change as NiFi and it's REST API evolve.
        // Parameters:
            // ID - the user group id.
            // body - the user group configuration details.
    func (client BaseClient) UpdateUserGroup(ctx context.Context, ID string, body UserGroupEntity) (result UserGroupEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UpdateUserGroup")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: body,
                 Constraints: []validation.Constraint{	{Target: "body.Component", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.Users", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                	{Target: "body.Component.AccessPolicies", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "body.Component.AccessPolicies", Name: validation.UniqueItems, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("nifi.BaseClient", "UpdateUserGroup", err.Error())
                }

                    req, err := client.UpdateUserGroupPreparer(ctx, ID, body)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUserGroup", nil , "Failure preparing request")
        return
        }

                resp, err := client.UpdateUserGroupSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUserGroup", resp, "Failure sending request")
                return
                }

                result, err = client.UpdateUserGroupResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UpdateUserGroup", resp, "Failure responding to request")
                }

        return
        }

        // UpdateUserGroupPreparer prepares the UpdateUserGroup request.
        func (client BaseClient) UpdateUserGroupPreparer(ctx context.Context, ID string, body UserGroupEntity) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

        preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/tenants/user-groups/{id}",pathParameters),
        autorest.WithJSON(body))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UpdateUserGroupSender sends the UpdateUserGroup request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UpdateUserGroupSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UpdateUserGroupResponder handles the response to the UpdateUserGroup request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UpdateUserGroupResponder(resp *http.Response) (result UserGroupEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusNotFound,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UploadTemplate sends the upload template request.
        // Parameters:
            // ID - the process group id.
    func (client BaseClient) UploadTemplate(ctx context.Context, ID string, templateParameter io.ReadCloser) (result TemplateEntity, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UploadTemplate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UploadTemplatePreparer(ctx, ID, templateParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UploadTemplate", nil , "Failure preparing request")
        return
        }

                resp, err := client.UploadTemplateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UploadTemplate", resp, "Failure sending request")
                return
                }

                result, err = client.UploadTemplateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "nifi.BaseClient", "UploadTemplate", resp, "Failure responding to request")
                }

        return
        }

        // UploadTemplatePreparer prepares the UploadTemplate request.
        func (client BaseClient) UploadTemplatePreparer(ctx context.Context, ID string, templateParameter io.ReadCloser) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                formDataParameters := map[string]interface{} {
                }
                    if templateParameter != nil {
                    formDataParameters["template"] = templateParameter
                    }

                preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/process-groups/{id}/templates/upload",pathParameters),
        autorest.WithMultiPartFormData(formDataParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UploadTemplateSender sends the UploadTemplate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UploadTemplateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UploadTemplateResponder handles the response to the UploadTemplate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UploadTemplateResponder(resp *http.Response) (result TemplateEntity, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusBadRequest,http.StatusUnauthorized,http.StatusForbidden,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

